shadow$provide.module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils=function(global,require,module,exports){global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0});exports.validateSections=exports.splitFormatIntoSections=exports.mergeDateIntoReferenceDate=exports.isAndroid=exports.getSectionsBoundaries=exports.getSectionVisibleValue=exports.getSectionOrder=exports.getLetterEditingOptions=
exports.getDaysInWeekStr=exports.getDateSectionConfigFromFormatToken=exports.getDateFromDateSections=exports.doesSectionHaveLeadingZeros=exports.createDateStrForInputFromSections=exports.cleanString=exports.cleanDigitSectionValue=exports.clampDaySectionIfPossible=exports.changeSectionValueFormat=exports.adjustSectionValue=exports.addPositionPropertiesToSections=void 0;var _extends2=global(require("module$node_modules$$babel$runtime$helpers$extends"));const getDateSectionConfigFromFormatToken=(utils,
formatToken)=>{utils=utils.formatTokenMap[formatToken];if(null==utils)throw Error([`MUI: The token "${formatToken}" is not supported by the Date and Time Pickers.`,"Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));return"string"===typeof utils?{type:utils,contentType:"meridiem"===utils?"letter":"digit"}:{type:utils.sectionType,contentType:utils.contentType}};exports.getDateSectionConfigFromFormatToken=
getDateSectionConfigFromFormatToken;const getDeltaFromKeyCode=keyCode=>{switch(keyCode){case "ArrowUp":return 1;case "ArrowDown":return-1;case "PageUp":return 5;case "PageDown":return-5;default:return 0}},getDaysInWeekStr=(utils,format)=>{const elements=[];var now=utils.date(),startDate=utils.startOfWeek(now);for(now=utils.endOfWeek(now);utils.isBefore(startDate,now);)elements.push(startDate),startDate=utils.addDays(startDate,1);return elements.map(weekDay=>utils.formatByString(weekDay,format))};
exports.getDaysInWeekStr=getDaysInWeekStr;const getLetterEditingOptions=(utils,sectionType,format)=>{switch(sectionType){case "month":return utils.getMonthArray(utils.date()).map(month=>utils.formatByString(month,format));case "weekDay":return getDaysInWeekStr(utils,format);case "meridiem":return sectionType=utils.date(),[utils.startOfDay(sectionType),utils.endOfDay(sectionType)].map(date=>utils.formatByString(date,format));default:return[]}};exports.getLetterEditingOptions=getLetterEditingOptions;
const cleanDigitSectionValue=(utils,value,sectionType,format,hasLeadingZeros,sectionBoundaries)=>{const hasLetter=()=>{var startOfYear=utils.startOfYear(utils.date());startOfYear=utils.formatByString(startOfYear,format);return Number.isNaN(Number(startOfYear))};if("day"!==sectionType&&hasLetter())throw Error([`MUI: The token "${format}" is a digit format with letter in it.'
             This type of format is only supported for 'day' sections`].join("\n"));if("day"===sectionType&&hasLetter())return hasLeadingZeros=utils.setDate(sectionBoundaries.longestMonth,value),utils.formatByString(hasLeadingZeros,format);value=value.toString();if(hasLeadingZeros){hasLeadingZeros=utils.formatByString(utils.date(),format).length;for(value=Number(value).toString();value.length<hasLeadingZeros;)value=`0${value}`;return value}return value};exports.cleanDigitSectionValue=cleanDigitSectionValue;
exports.adjustSectionValue=(utils,section,keyCode,sectionsValueBoundaries,activeDate)=>{const delta=getDeltaFromKeyCode(keyCode),isStart="Home"===keyCode,isEnd="End"===keyCode,shouldSetAbsolute=""===section.value||isStart||isEnd;keyCode=()=>{const sectionBoundaries=sectionsValueBoundaries[section.type]({currentDate:activeDate,format:section.format,contentType:section.contentType}),getCleanValue=value=>cleanDigitSectionValue(utils,value,section.type,section.format,section.hasLeadingZeros,sectionBoundaries);
if(shouldSetAbsolute)return"year"!==section.type||isEnd||isStart?0<delta||isStart?getCleanValue(sectionBoundaries.minimum):getCleanValue(sectionBoundaries.maximum):utils.formatByString(utils.date(),section.format);const newSectionValueNumber=parseInt(section.value,10)+delta;return newSectionValueNumber>sectionBoundaries.maximum?getCleanValue(sectionBoundaries.minimum):newSectionValueNumber<sectionBoundaries.minimum?getCleanValue(sectionBoundaries.maximum):getCleanValue(newSectionValueNumber)};return"digit"===
section.contentType?keyCode():(()=>{const options=getLetterEditingOptions(utils,section.type,section.format);if(0===options.length)return section.value;if(shouldSetAbsolute)return 0<delta||isStart?options[0]:options[options.length-1];const newOptionIndex=(options.indexOf(section.value)+options.length+delta)%options.length;return options[newOptionIndex]})()};const getSectionVisibleValue=(section,target)=>{let value=section.value||section.placeholder;["input-rtl","input-ltr"].includes(target)&&"digit"===
section.contentType&&!section.hasLeadingZeros&&1===value.length&&(value=`${value}\u200e`);"input-rtl"===target&&(value=`\u2068${value}\u2069`);return value};exports.getSectionVisibleValue=getSectionVisibleValue;const cleanString=dirtyString=>dirtyString.replace(/[\u2066\u2067\u2068\u2069]/g,"");exports.cleanString=cleanString;exports.addPositionPropertiesToSections=(sections,isRTL)=>{let position=0,positionInInput=isRTL?1:0;const newSections=[];for(let i=0;i<sections.length;i+=1){const section=sections[i];
var renderedValue=getSectionVisibleValue(section,isRTL?"input-rtl":"input-ltr"),sectionStr=`${section.startSeparator}${renderedValue}${section.endSeparator}`;const sectionLength=cleanString(sectionStr).length;sectionStr=sectionStr.length;const cleanedValue=cleanString(renderedValue);renderedValue=positionInInput+renderedValue.indexOf(cleanedValue[0])+section.startSeparator.length;newSections.push((0,_extends2.default)({},section,{start:position,end:position+sectionLength,startInInput:renderedValue,
endInInput:renderedValue+cleanedValue.length}));position+=sectionLength;positionInInput+=sectionStr}return newSections};const getSectionPlaceholder=(utils,localeText,sectionConfig,currentTokenValue)=>{switch(sectionConfig.type){case "year":return localeText.fieldYearPlaceholder({digitAmount:utils.formatByString(utils.date(),currentTokenValue).length});case "month":return localeText.fieldMonthPlaceholder({contentType:sectionConfig.contentType});case "day":return localeText.fieldDayPlaceholder();case "weekDay":return localeText.fieldWeekDayPlaceholder({contentType:sectionConfig.contentType});
case "hours":return localeText.fieldHoursPlaceholder();case "minutes":return localeText.fieldMinutesPlaceholder();case "seconds":return localeText.fieldSecondsPlaceholder();case "meridiem":return localeText.fieldMeridiemPlaceholder();default:return currentTokenValue}};exports.changeSectionValueFormat=(utils,valueStr,currentFormat,newFormat)=>{if("weekDay"===getDateSectionConfigFromFormatToken(utils,currentFormat).type)throw Error("changeSectionValueFormat doesn't support week day formats");return utils.formatByString(utils.parse(valueStr,
currentFormat),newFormat)};const doesSectionHaveLeadingZeros=(utils,contentType,sectionType,format)=>{if("digit"!==contentType)return!1;switch(sectionType){case "year":return 4===utils.formatByString(utils.date(),format).length?"0001"===utils.formatByString(utils.setYear(utils.date(),1),format):"01"===utils.formatByString(utils.setYear(utils.date(),2001),format);case "month":return 1<utils.formatByString(utils.startOfYear(utils.date()),format).length;case "day":return 1<utils.formatByString(utils.startOfMonth(utils.date()),
format).length;case "weekDay":return 1<utils.formatByString(utils.startOfWeek(utils.date()),format).length;case "hours":return 1<utils.formatByString(utils.setHours(utils.date(),1),format).length;case "minutes":return 1<utils.formatByString(utils.setMinutes(utils.date(),1),format).length;case "seconds":return 1<utils.formatByString(utils.setMinutes(utils.date(),1),format).length;default:throw Error("Invalid section type");}};exports.doesSectionHaveLeadingZeros=doesSectionHaveLeadingZeros;const getEscapedPartsFromFormat=
(utils,format)=>{const escapedParts=[],{start:startChar,end:endChar}=utils.escapedCharacters;utils=new RegExp(`(\\${startChar}[^\\${endChar}]*\\${endChar})+`,"g");let match;for(;match=utils.exec(format);)escapedParts.push({start:match.index,end:utils.lastIndex-1});return escapedParts};exports.splitFormatIntoSections=(utils,localeText,format,date,formatDensity)=>{let startSeparator="";const sections=[],commitToken=token=>{if(""===token)return null;const sectionConfig=getDateSectionConfigFromFormatToken(utils,
token),sectionValue=null!=date&&utils.isValid(date)?utils.formatByString(date,token):"",hasLeadingZeros=doesSectionHaveLeadingZeros(utils,sectionConfig.contentType,sectionConfig.type,token);sections.push((0,_extends2.default)({},sectionConfig,{format:token,value:sectionValue,placeholder:getSectionPlaceholder(utils,localeText,sectionConfig,token),hasLeadingZeros,startSeparator:0===sections.length?startSeparator:"",endSeparator:"",modified:!1}));return null};var formatExpansionOverflow=10,prevFormat=
format;for(format=utils.expandFormat(format);format!==prevFormat;)if(prevFormat=format,format=utils.expandFormat(prevFormat),--formatExpansionOverflow,0>formatExpansionOverflow)throw Error("MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component");formatExpansionOverflow=format;prevFormat=getEscapedPartsFromFormat(utils,formatExpansionOverflow);format=new RegExp(`^(${Object.keys(utils.formatTokenMap).join("|")})`);let currentTokenValue=
"";for(let i=0;i<formatExpansionOverflow.length;i+=1){const escapedPartOfCurrentChar=prevFormat.find(escapeIndex=>escapeIndex.start<=i&&escapeIndex.end>=i),char=formatExpansionOverflow[i],isEscapedChar=null!=escapedPartOfCurrentChar,potentialToken=`${currentTokenValue}${formatExpansionOverflow.slice(i)}`;!isEscapedChar&&char.match(/([A-Za-z]+)/)&&format.test(potentialToken)?currentTokenValue+=char:isEscapedChar&&escapedPartOfCurrentChar?.start===i||escapedPartOfCurrentChar?.end===i||(commitToken(currentTokenValue),
currentTokenValue="",0===sections.length?startSeparator+=char:sections[sections.length-1].endSeparator+=char)}commitToken(currentTokenValue);return sections.map(section=>{const cleanSeparator=separator=>{null!==separator&&separator.includes(" ")&&(separator=`\u2069${separator}\u2066`);"spacious"===formatDensity&&["/",".","-"].includes(separator)&&(separator=` ${separator} `);return separator};section.startSeparator=cleanSeparator(section.startSeparator);section.endSeparator=cleanSeparator(section.endSeparator);
return section})};const getDateFromDateSections=(utils,sections)=>{const shouldSkipWeekDays=sections.some(section=>"day"===section.type),sectionFormats=[];var sectionValues=[];for(let i=0;i<sections.length;i+=1){const section=sections[i];shouldSkipWeekDays&&"weekDay"===section.type||(sectionFormats.push(section.format),sectionValues.push(getSectionVisibleValue(section,"non-input")))}sections=sectionFormats.join(" ");sectionValues=sectionValues.join(" ");return utils.parse(sectionValues,sections)};
exports.getDateFromDateSections=getDateFromDateSections;exports.createDateStrForInputFromSections=(sections,isRTL)=>{sections=sections.map(section=>`${section.startSeparator}${getSectionVisibleValue(section,isRTL?"input-rtl":"input-ltr")}${section.endSeparator}`).join("");return isRTL?`\u2066${sections}\u2069`:sections};exports.getSectionsBoundaries=utils=>{const today=utils.date(),endOfYear=utils.endOfYear(today),{maxDaysInMonth,longestMonth}=utils.getMonthArray(today).reduce((acc,month)=>{const daysInMonth=
utils.getDaysInMonth(month);return daysInMonth>acc.maxDaysInMonth?{maxDaysInMonth:daysInMonth,longestMonth:month}:acc},{maxDaysInMonth:0,longestMonth:null});return{year:({format})=>({minimum:0,maximum:4===utils.formatByString(utils.date(),format).length?9999:99}),month:()=>({minimum:1,maximum:utils.getMonth(endOfYear)+1}),day:({currentDate})=>({minimum:1,maximum:null!=currentDate&&utils.isValid(currentDate)?utils.getDaysInMonth(currentDate):maxDaysInMonth,longestMonth}),weekDay:({format,contentType})=>
"digit"===contentType?(format=getDaysInWeekStr(utils,format).map(Number),{minimum:Math.min(...format),maximum:Math.max(...format)}):{minimum:1,maximum:7},hours:({format})=>{const lastHourInDay=utils.getHours(endOfYear);return utils.formatByString(utils.endOfDay(today),format)!==lastHourInDay.toString()?{minimum:1,maximum:Number(utils.formatByString(utils.startOfDay(today),format))}:{minimum:0,maximum:lastHourInDay}},minutes:()=>({minimum:0,maximum:utils.getMinutes(endOfYear)}),seconds:()=>({minimum:0,
maximum:utils.getSeconds(endOfYear)}),meridiem:()=>({minimum:0,maximum:0})}};let warnedOnceInvalidSection=!1;exports.validateSections=(sections,valueType)=>{if(!warnedOnceInvalidSection){const supportedSections=[];["date","date-time"].includes(valueType)&&supportedSections.push("weekDay","day","month","year");["time","date-time"].includes(valueType)&&supportedSections.push("hours","minutes","seconds","meridiem");if(sections=sections.find(section=>!supportedSections.includes(section.type)))console.warn(`MUI: The field component you are using is not compatible with the "${sections.type} date section.`,
`The supported date sections are ["${supportedSections.join('", "')}"]\`.`),warnedOnceInvalidSection=!0}};const transferDateSectionValue=(utils,section,dateToTransferFrom,dateToTransferTo)=>{switch(section.type){case "year":return utils.setYear(dateToTransferTo,utils.getYear(dateToTransferFrom));case "month":return utils.setMonth(dateToTransferTo,utils.getMonth(dateToTransferFrom));case "weekDay":dateToTransferTo=getDaysInWeekStr(utils,section.format);var dayInWeekStrOfActiveDate=utils.formatByString(dateToTransferFrom,
section.format);dayInWeekStrOfActiveDate=dateToTransferTo.indexOf(dayInWeekStrOfActiveDate);section=dateToTransferTo.indexOf(section.value);return utils.addDays(dateToTransferFrom,section-dayInWeekStrOfActiveDate);case "day":return utils.setDate(dateToTransferTo,utils.getDate(dateToTransferFrom));case "meridiem":return dateToTransferFrom=12>utils.getHours(dateToTransferFrom),section=utils.getHours(dateToTransferTo),dateToTransferFrom&&12<=section?utils.addHours(dateToTransferTo,-12):!dateToTransferFrom&&
12>section?utils.addHours(dateToTransferTo,12):dateToTransferTo;case "hours":return utils.setHours(dateToTransferTo,utils.getHours(dateToTransferFrom));case "minutes":return utils.setMinutes(dateToTransferTo,utils.getMinutes(dateToTransferFrom));case "seconds":return utils.setSeconds(dateToTransferTo,utils.getSeconds(dateToTransferFrom));default:return dateToTransferTo}},reliableSectionModificationOrder={year:1,month:2,day:3,weekDay:4,hours:5,minutes:6,seconds:7,meridiem:8};exports.mergeDateIntoReferenceDate=
(utils,dateToTransferFrom,sections,referenceDate,shouldLimitToEditedSections)=>[...sections].sort((a,b)=>reliableSectionModificationOrder[a.type]-reliableSectionModificationOrder[b.type]).reduce((mergedDate,section)=>!shouldLimitToEditedSections||section.modified?transferDateSectionValue(utils,section,dateToTransferFrom,mergedDate):mergedDate,referenceDate);exports.isAndroid=()=>-1<navigator.userAgent.toLowerCase().indexOf("android");exports.clampDaySectionIfPossible=(utils,sections,sectionsValueBoundaries)=>
{if(!sections.every(section=>"weekDay"===section.type||""!==section.value)||!sections.some(section=>"day"===section.type))return null;const sectionsForStartOfMonth=sections.map(section=>{if("day"!==section.type)return section;const dayBoundaries=sectionsValueBoundaries.day({currentDate:null,format:section.format,contentType:section.contentType});return(0,_extends2.default)({},section,{value:cleanDigitSectionValue(utils,dayBoundaries.minimum,section.type,section.format,section.hasLeadingZeros,dayBoundaries)})}),
startOfMonth=getDateFromDateSections(utils,sectionsForStartOfMonth);return null!=startOfMonth&&utils.isValid(startOfMonth)?sections.map(section=>{if("day"!==section.type)return section;const dayBoundaries=sectionsValueBoundaries.day({currentDate:startOfMonth,format:section.format,contentType:section.contentType});return Number(section.value)<=dayBoundaries.maximum?section:(0,_extends2.default)({},section,{value:dayBoundaries.maximum.toString()})}):null};exports.getSectionOrder=(sections,isRTL)=>{const neighbors=
{};if(!isRTL)return sections.forEach((_,index)=>{neighbors[index]={leftIndex:0===index?null:index-1,rightIndex:index===sections.length-1?null:index+1}}),{neighbors,startIndex:0,endIndex:sections.length-1};const rtl2ltr={},ltr2rtl={};let groupedSectionsStart=0;isRTL=0;let RTLIndex=sections.length-1;for(;0<=RTLIndex;){isRTL=sections.findIndex((section,index)=>index>=groupedSectionsStart&&section.endSeparator?.includes(" ")&&" / "!==section.endSeparator);-1===isRTL&&(isRTL=sections.length-1);for(let i=
isRTL;i>=groupedSectionsStart;--i)ltr2rtl[i]=RTLIndex,rtl2ltr[RTLIndex]=i,--RTLIndex;groupedSectionsStart=isRTL+1}sections.forEach((_,index)=>{_=ltr2rtl[index];neighbors[index]={leftIndex:0===_?null:rtl2ltr[_-1],rightIndex:_===sections.length-1?null:rtl2ltr[_+1]}});return{neighbors,startIndex:rtl2ltr[0],endIndex:rtl2ltr[sections.length-1]}}}
//# sourceMappingURL=module$node_modules$$mui$x_date_pickers$node$internals$hooks$useField$useField_utils.js.map
