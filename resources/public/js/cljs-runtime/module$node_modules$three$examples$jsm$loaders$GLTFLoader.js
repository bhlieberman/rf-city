shadow$provide.module$node_modules$three$examples$jsm$loaders$GLTFLoader=function(global,require,module,exports){function GLTFRegistry(){let objects={};return{get:function(key){return objects[key]},add:function(key,object){objects[key]=object},remove:function(key){delete objects[key]},removeAll:function(){objects={}}}}function createDefaultMaterial(cache){void 0===cache.DefaultMaterial&&(cache.DefaultMaterial=new _three.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,
depthTest:!0,side:_three.FrontSide}));return cache.DefaultMaterial}function addUnknownExtensionsToUserData(knownExtensions,object,objectDef){for(const name in objectDef.extensions)void 0===knownExtensions[name]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[name]=objectDef.extensions[name])}function assignExtrasToUserData(object,gltfDef){void 0!==gltfDef.extras&&("object"===typeof gltfDef.extras?Object.assign(object.userData,gltfDef.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+
gltfDef.extras))}function addMorphTargets(geometry,targets,parser){let hasMorphPosition=!1,hasMorphNormal=!1,hasMorphColor=!1;for(let i=0,il=targets.length;i<il;i++){var target=targets[i];void 0!==target.POSITION&&(hasMorphPosition=!0);void 0!==target.NORMAL&&(hasMorphNormal=!0);void 0!==target.COLOR_0&&(hasMorphColor=!0);if(hasMorphPosition&&hasMorphNormal&&hasMorphColor)break}if(!hasMorphPosition&&!hasMorphNormal&&!hasMorphColor)return Promise.resolve(geometry);target=[];const pendingNormalAccessors=
[],pendingColorAccessors=[];for(let i=0,il=targets.length;i<il;i++){var target$jscomp$0=targets[i];if(hasMorphPosition){var pendingAccessor=void 0!==target$jscomp$0.POSITION?parser.getDependency("accessor",target$jscomp$0.POSITION):geometry.attributes.position;target.push(pendingAccessor)}hasMorphNormal&&(pendingAccessor=void 0!==target$jscomp$0.NORMAL?parser.getDependency("accessor",target$jscomp$0.NORMAL):geometry.attributes.normal,pendingNormalAccessors.push(pendingAccessor));hasMorphColor&&(target$jscomp$0=
void 0!==target$jscomp$0.COLOR_0?parser.getDependency("accessor",target$jscomp$0.COLOR_0):geometry.attributes.color,pendingColorAccessors.push(target$jscomp$0))}return Promise.all([Promise.all(target),Promise.all(pendingNormalAccessors),Promise.all(pendingColorAccessors)]).then(function(accessors){const morphPositions=accessors[0],morphNormals=accessors[1];accessors=accessors[2];hasMorphPosition&&(geometry.morphAttributes.position=morphPositions);hasMorphNormal&&(geometry.morphAttributes.normal=morphNormals);
hasMorphColor&&(geometry.morphAttributes.color=accessors);geometry.morphTargetsRelative=!0;return geometry})}function createPrimitiveKey(primitiveDef){const dracoExtension=primitiveDef.extensions&&primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];return dracoExtension?"draco:"+dracoExtension.bufferView+":"+dracoExtension.indices+":"+createAttributesKey(dracoExtension.attributes):primitiveDef.indices+":"+createAttributesKey(primitiveDef.attributes)+":"+primitiveDef.mode}function createAttributesKey(attributes){let attributesKey=
"";const keys=Object.keys(attributes).sort();for(let i=0,il=keys.length;i<il;i++)attributesKey+=keys[i]+":"+attributes[keys[i]]+";";return attributesKey}function getNormalizedComponentScale(constructor){switch(constructor){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");}}function computeBounds(geometry,primitiveDef,parser){var attributes=
primitiveDef.attributes;const box=new _three.Box3;if(void 0!==attributes.POSITION){attributes=parser.json.accessors[attributes.POSITION];var min$jscomp$0=attributes.min,max$jscomp$0=attributes.max;if(void 0!==min$jscomp$0&&void 0!==max$jscomp$0){box.set(new _three.Vector3(min$jscomp$0[0],min$jscomp$0[1],min$jscomp$0[2]),new _three.Vector3(max$jscomp$0[0],max$jscomp$0[1],max$jscomp$0[2]));attributes.normalized&&(attributes=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[attributes.componentType]),
box.min.multiplyScalar(attributes),box.max.multiplyScalar(attributes));primitiveDef=primitiveDef.targets;if(void 0!==primitiveDef){attributes=new _three.Vector3;min$jscomp$0=new _three.Vector3;for(let i=0,il=primitiveDef.length;i<il;i++)if(max$jscomp$0=primitiveDef[i],void 0!==max$jscomp$0.POSITION){max$jscomp$0=parser.json.accessors[max$jscomp$0.POSITION];const min=max$jscomp$0.min,max=max$jscomp$0.max;void 0!==min&&void 0!==max?(min$jscomp$0.setX(Math.max(Math.abs(min[0]),Math.abs(max[0]))),min$jscomp$0.setY(Math.max(Math.abs(min[1]),
Math.abs(max[1]))),min$jscomp$0.setZ(Math.max(Math.abs(min[2]),Math.abs(max[2]))),max$jscomp$0.normalized&&(max$jscomp$0=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[max$jscomp$0.componentType]),min$jscomp$0.multiplyScalar(max$jscomp$0)),attributes.max(min$jscomp$0)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}box.expandByVector(attributes)}geometry.boundingBox=box;parser=new _three.Sphere;box.getCenter(parser.center);parser.radius=box.min.distanceTo(box.max)/
2;geometry.boundingSphere=parser}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}function addPrimitiveAttributes(geometry,primitiveDef,parser){function assignAttributeAccessor(accessorIndex,attributeName){return parser.getDependency("accessor",accessorIndex).then(function(accessor){geometry.setAttribute(attributeName,accessor)})}var attributes=primitiveDef.attributes;const pending=[];for(const gltfAttributeName in attributes){const threeAttributeName=ATTRIBUTES[gltfAttributeName]||
gltfAttributeName.toLowerCase();threeAttributeName in geometry.attributes||pending.push(assignAttributeAccessor(attributes[gltfAttributeName],threeAttributeName))}void 0===primitiveDef.indices||geometry.index||(attributes=parser.getDependency("accessor",primitiveDef.indices).then(function(accessor){geometry.setIndex(accessor)}),pending.push(attributes));assignExtrasToUserData(geometry,primitiveDef);computeBounds(geometry,primitiveDef,parser);return Promise.all(pending).then(function(){return void 0!==
primitiveDef.targets?addMorphTargets(geometry,primitiveDef.targets,parser):geometry})}Object.defineProperty(exports,"__esModule",{value:!0});exports.GLTFLoader=void 0;var _three=require("module$node_modules$three$build$three"),_BufferGeometryUtils=require("module$node_modules$three$examples$jsm$utils$BufferGeometryUtils");class GLTFLoader extends _three.Loader{constructor(manager){super(manager);this.meshoptDecoder=this.ktx2Loader=this.dracoLoader=null;this.pluginCallbacks=[];this.register(function(parser){return new GLTFMaterialsClearcoatExtension(parser)});
this.register(function(parser){return new GLTFTextureBasisUExtension(parser)});this.register(function(parser){return new GLTFTextureWebPExtension(parser)});this.register(function(parser){return new GLTFTextureAVIFExtension(parser)});this.register(function(parser){return new GLTFMaterialsSheenExtension(parser)});this.register(function(parser){return new GLTFMaterialsTransmissionExtension(parser)});this.register(function(parser){return new GLTFMaterialsVolumeExtension(parser)});this.register(function(parser){return new GLTFMaterialsIorExtension(parser)});
this.register(function(parser){return new GLTFMaterialsEmissiveStrengthExtension(parser)});this.register(function(parser){return new GLTFMaterialsSpecularExtension(parser)});this.register(function(parser){return new GLTFMaterialsIridescenceExtension(parser)});this.register(function(parser){return new GLTFLightsExtension(parser)});this.register(function(parser){return new GLTFMeshoptCompression(parser)});this.register(function(parser){return new GLTFMeshGpuInstancing(parser)})}load(url,onLoad,onProgress,
onError){const scope=this;let resourcePath;resourcePath=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:_three.LoaderUtils.extractUrlBase(url);this.manager.itemStart(url);const _onError=function(e){onError?onError(e):console.error(e);scope.manager.itemError(url);scope.manager.itemEnd(url)},loader=new _three.FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType("arraybuffer");loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);
loader.load(url,function(data){try{scope.parse(data,resourcePath,function(gltf){onLoad(gltf);scope.manager.itemEnd(url)},_onError)}catch(e){_onError(e)}},onProgress,_onError)}setDRACOLoader(dracoLoader){this.dracoLoader=dracoLoader;return this}setDDSLoader(){throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');}setKTX2Loader(ktx2Loader){this.ktx2Loader=ktx2Loader;return this}setMeshoptDecoder(meshoptDecoder){this.meshoptDecoder=meshoptDecoder;
return this}register(callback){-1===this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.push(callback);return this}unregister(callback){-1!==this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback),1);return this}parse(data,path,onLoad,onError){const extensions={},plugins={};var textDecoder=new TextDecoder;if("string"===typeof data)data=JSON.parse(data);else if(data instanceof ArrayBuffer)if("glTF"===textDecoder.decode(new Uint8Array(data,
0,4))){try{extensions[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(data)}catch(error){onError&&onError(error);return}data=JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)}else data=JSON.parse(textDecoder.decode(data));if(void 0===data.asset||2>data.asset.version[0])onError&&onError(Error("THREE.GLTFLoader: Unsupported asset. glTF versions \x3e\x3d2.0 are supported."));else{path=new GLTFParser(data,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,
manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});path.fileLoader.setRequestHeader(this.requestHeader);for(textDecoder=0;textDecoder<this.pluginCallbacks.length;textDecoder++){var plugin=this.pluginCallbacks[textDecoder](path);plugins[plugin.name]=plugin;extensions[plugin.name]=!0}if(data.extensionsUsed)for(textDecoder=0;textDecoder<data.extensionsUsed.length;++textDecoder){plugin=data.extensionsUsed[textDecoder];const extensionsRequired=data.extensionsRequired||
[];switch(plugin){case EXTENSIONS.KHR_MATERIALS_UNLIT:extensions[plugin]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:extensions[plugin]=new GLTFDracoMeshCompressionExtension(data,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:extensions[plugin]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:extensions[plugin]=new GLTFMeshQuantizationExtension;break;default:0<=extensionsRequired.indexOf(plugin)&&void 0===plugins[plugin]&&
console.warn('THREE.GLTFLoader: Unknown extension "'+plugin+'".')}}path.setExtensions(extensions);path.setPlugins(plugins);path.parse(onLoad,onError)}}parseAsync(data,path){const scope=this;return new Promise(function(resolve,reject){scope.parse(data,path,resolve,reject)})}}exports.GLTFLoader=GLTFLoader;const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",
KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",
EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL;this.cache={refs:{},uses:{}}}_markDefs(){const parser=this.parser,nodeDefs=this.parser.json.nodes||[];for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){const nodeDef=nodeDefs[nodeIndex];nodeDef.extensions&&
nodeDef.extensions[this.name]&&void 0!==nodeDef.extensions[this.name].light&&parser._addNodeRef(this.cache,nodeDef.extensions[this.name].light)}}_loadLight(lightIndex){const parser=this.parser,cacheKey="light:"+lightIndex;var dependency=parser.cache.get(cacheKey);if(dependency)return dependency;dependency=parser.json;dependency=((dependency.extensions&&dependency.extensions[this.name]||{}).lights||[])[lightIndex];var lightNode=new _three.Color(16777215);void 0!==dependency.color&&lightNode.fromArray(dependency.color);
const range=void 0!==dependency.range?dependency.range:0;switch(dependency.type){case "directional":lightNode=new _three.DirectionalLight(lightNode);lightNode.target.position.set(0,0,-1);lightNode.add(lightNode.target);break;case "point":lightNode=new _three.PointLight(lightNode);lightNode.distance=range;break;case "spot":lightNode=new _three.SpotLight(lightNode);lightNode.distance=range;dependency.spot=dependency.spot||{};dependency.spot.innerConeAngle=void 0!==dependency.spot.innerConeAngle?dependency.spot.innerConeAngle:
0;dependency.spot.outerConeAngle=void 0!==dependency.spot.outerConeAngle?dependency.spot.outerConeAngle:Math.PI/4;lightNode.angle=dependency.spot.outerConeAngle;lightNode.penumbra=1-dependency.spot.innerConeAngle/dependency.spot.outerConeAngle;lightNode.target.position.set(0,0,-1);lightNode.add(lightNode.target);break;default:throw Error("THREE.GLTFLoader: Unexpected light type: "+dependency.type);}lightNode.position.set(0,0,0);lightNode.decay=2;assignExtrasToUserData(lightNode,dependency);void 0!==
dependency.intensity&&(lightNode.intensity=dependency.intensity);lightNode.name=parser.createUniqueName(dependency.name||"light_"+lightIndex);dependency=Promise.resolve(lightNode);parser.cache.add(cacheKey,dependency);return dependency}getDependency(type,index){if("light"===type)return this._loadLight(index)}createNodeAttachment(nodeIndex){const self=this,parser=this.parser;nodeIndex=parser.json.nodes[nodeIndex];const lightIndex=(nodeIndex.extensions&&nodeIndex.extensions[this.name]||{}).light;return void 0===
lightIndex?null:this._loadLight(lightIndex).then(function(light){return parser._getNodeRef(self.cache,lightIndex,light)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return _three.MeshBasicMaterial}extendParams(materialParams,materialDef,parser){const pending=[];materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;if(materialDef=materialDef.pbrMetallicRoughness){if(Array.isArray(materialDef.baseColorFactor)){const array=
materialDef.baseColorFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==materialDef.baseColorTexture&&pending.push(parser.assignTexture(materialParams,"map",materialDef.baseColorTexture,_three.sRGBEncoding))}return Promise.all(pending)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(materialIndex,materialParams){materialIndex=this.parser.json.materials[materialIndex];
if(!materialIndex.extensions||!materialIndex.extensions[this.name])return Promise.resolve();materialIndex=materialIndex.extensions[this.name].emissiveStrength;void 0!==materialIndex&&(materialParams.emissiveIntensity=materialIndex);return Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?
_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.clearcoatFactor&&(materialParams.clearcoat=materialDef.clearcoatFactor);void 0!==materialDef.clearcoatTexture&&materialIndex.push(parser.assignTexture(materialParams,"clearcoatMap",
materialDef.clearcoatTexture));void 0!==materialDef.clearcoatRoughnessFactor&&(materialParams.clearcoatRoughness=materialDef.clearcoatRoughnessFactor);void 0!==materialDef.clearcoatRoughnessTexture&&materialIndex.push(parser.assignTexture(materialParams,"clearcoatRoughnessMap",materialDef.clearcoatRoughnessTexture));void 0!==materialDef.clearcoatNormalTexture&&(materialIndex.push(parser.assignTexture(materialParams,"clearcoatNormalMap",materialDef.clearcoatNormalTexture)),void 0!==materialDef.clearcoatNormalTexture.scale&&
(parser=materialDef.clearcoatNormalTexture.scale,materialParams.clearcoatNormalScale=new _three.Vector2(parser,parser)));return Promise.all(materialIndex)}}class GLTFMaterialsIridescenceExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,
materialParams){const parser=this.parser;var materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.iridescenceFactor&&(materialParams.iridescence=materialDef.iridescenceFactor);void 0!==materialDef.iridescenceTexture&&materialIndex.push(parser.assignTexture(materialParams,"iridescenceMap",materialDef.iridescenceTexture));void 0!==materialDef.iridescenceIor&&
(materialParams.iridescenceIOR=materialDef.iridescenceIor);void 0===materialParams.iridescenceThicknessRange&&(materialParams.iridescenceThicknessRange=[100,400]);void 0!==materialDef.iridescenceThicknessMinimum&&(materialParams.iridescenceThicknessRange[0]=materialDef.iridescenceThicknessMinimum);void 0!==materialDef.iridescenceThicknessMaximum&&(materialParams.iridescenceThicknessRange[1]=materialDef.iridescenceThicknessMaximum);void 0!==materialDef.iridescenceThicknessTexture&&materialIndex.push(parser.assignTexture(materialParams,
"iridescenceThicknessMap",materialDef.iridescenceThicknessTexture));return Promise.all(materialIndex)}}class GLTFMaterialsSheenExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser;var materialDef=parser.json.materials[materialIndex];
if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialParams.sheenColor=new _three.Color(0,0,0);materialParams.sheenRoughness=0;materialParams.sheen=1;materialDef=materialDef.extensions[this.name];void 0!==materialDef.sheenColorFactor&&materialParams.sheenColor.fromArray(materialDef.sheenColorFactor);void 0!==materialDef.sheenRoughnessFactor&&(materialParams.sheenRoughness=materialDef.sheenRoughnessFactor);void 0!==materialDef.sheenColorTexture&&
materialIndex.push(parser.assignTexture(materialParams,"sheenColorMap",materialDef.sheenColorTexture,_three.sRGBEncoding));void 0!==materialDef.sheenRoughnessTexture&&materialIndex.push(parser.assignTexture(materialParams,"sheenRoughnessMap",materialDef.sheenRoughnessTexture));return Promise.all(materialIndex)}}class GLTFMaterialsTransmissionExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];
return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser;var materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.transmissionFactor&&(materialParams.transmission=materialDef.transmissionFactor);void 0!==materialDef.transmissionTexture&&
materialIndex.push(parser.assignTexture(materialParams,"transmissionMap",materialDef.transmissionTexture));return Promise.all(materialIndex)}}class GLTFMaterialsVolumeExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){var parser=
this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];materialParams.thickness=void 0!==materialDef.thicknessFactor?materialDef.thicknessFactor:0;void 0!==materialDef.thicknessTexture&&materialIndex.push(parser.assignTexture(materialParams,"thicknessMap",materialDef.thicknessTexture));materialParams.attenuationDistance=materialDef.attenuationDistance||
Infinity;parser=materialDef.attenuationColor||[1,1,1];materialParams.attenuationColor=new _three.Color(parser[0],parser[1],parser[2]);return Promise.all(materialIndex)}}class GLTFMaterialsIorExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,
materialParams){materialIndex=this.parser.json.materials[materialIndex];if(!materialIndex.extensions||!materialIndex.extensions[this.name])return Promise.resolve();materialIndex=materialIndex.extensions[this.name];materialParams.ior=void 0!==materialIndex.ior?materialIndex.ior:1.5;return Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(materialIndex){materialIndex=this.parser.json.materials[materialIndex];
return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser;var materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];materialParams.specularIntensity=void 0!==materialDef.specularFactor?materialDef.specularFactor:1;void 0!==materialDef.specularTexture&&
materialIndex.push(parser.assignTexture(materialParams,"specularIntensityMap",materialDef.specularTexture));const colorArray=materialDef.specularColorFactor||[1,1,1];materialParams.specularColor=new _three.Color(colorArray[0],colorArray[1],colorArray[2]);void 0!==materialDef.specularColorTexture&&materialIndex.push(parser.assignTexture(materialParams,"specularColorMap",materialDef.specularColorTexture,_three.sRGBEncoding));return Promise.all(materialIndex)}}class GLTFTextureBasisUExtension{constructor(parser){this.parser=
parser;this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(textureIndex){const parser=this.parser,json=parser.json;var textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[this.name])return null;textureDef=textureDef.extensions[this.name];const loader=parser.options.ktx2Loader;if(!loader){if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(this.name))throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return parser.loadTextureImage(textureIndex,
textureDef.source,loader)}}class GLTFTextureWebPExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.EXT_TEXTURE_WEBP;this.isSupported=null}loadTexture(textureIndex){const name=this.name,parser=this.parser,json=parser.json;var textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;const extension=textureDef.extensions[name];textureDef=json.images[extension.source];let loader=parser.textureLoader;textureDef.uri&&(textureDef=parser.options.manager.getHandler(textureDef.uri),
null!==textureDef&&(loader=textureDef));return this.detectSupport().then(function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,extension.source,loader);if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(name))throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return parser.loadTexture(textureIndex)})}detectSupport(){this.isSupported||(this.isSupported=new Promise(function(resolve){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
image.onload=image.onerror=function(){resolve(1===image.height)}}));return this.isSupported}}class GLTFTextureAVIFExtension{constructor(parser){this.parser=parser;this.name=EXTENSIONS.EXT_TEXTURE_AVIF;this.isSupported=null}loadTexture(textureIndex){const name=this.name,parser=this.parser,json=parser.json;var textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;const extension=textureDef.extensions[name];textureDef=json.images[extension.source];
let loader=parser.textureLoader;textureDef.uri&&(textureDef=parser.options.manager.getHandler(textureDef.uri),null!==textureDef&&(loader=textureDef));return this.detectSupport().then(function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,extension.source,loader);if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(name))throw Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return parser.loadTexture(textureIndex)})}detectSupport(){this.isSupported||
(this.isSupported=new Promise(function(resolve){const image=new Image;image.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI\x3d";
image.onload=image.onerror=function(){resolve(1===image.height)}}));return this.isSupported}}class GLTFMeshoptCompression{constructor(parser){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION;this.parser=parser}loadBufferView(index){const json=this.parser.json;index=json.bufferViews[index];if(index.extensions&&index.extensions[this.name]){const extensionDef=index.extensions[this.name];index=this.parser.getDependency("buffer",extensionDef.buffer);const decoder=this.parser.options.meshoptDecoder;if(!decoder||
!decoder.supported){if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(this.name))throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return index.then(function(res$jscomp$0){const count=extensionDef.count,stride=extensionDef.byteStride,source=new Uint8Array(res$jscomp$0,extensionDef.byteOffset||0,extensionDef.byteLength||0);return decoder.decodeGltfBufferAsync?decoder.decodeGltfBufferAsync(count,stride,source,extensionDef.mode,
extensionDef.filter).then(function(res){return res.buffer}):decoder.ready.then(function(){const result=new ArrayBuffer(count*stride);decoder.decodeGltfBuffer(new Uint8Array(result),count,stride,source,extensionDef.mode,extensionDef.filter);return result})})}return null}}class GLTFMeshGpuInstancing{constructor(parser){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING;this.parser=parser}createNodeMesh(nodeIndex){var json=this.parser.json,nodeDef=json.nodes[nodeIndex];if(!nodeDef.extensions||!nodeDef.extensions[this.name]||
void 0===nodeDef.mesh)return null;json=json.meshes[nodeDef.mesh];for(var primitive of json.primitives)if(primitive.mode!==WEBGL_CONSTANTS.TRIANGLES&&primitive.mode!==WEBGL_CONSTANTS.TRIANGLE_STRIP&&primitive.mode!==WEBGL_CONSTANTS.TRIANGLE_FAN&&void 0!==primitive.mode)return null;nodeDef=nodeDef.extensions[this.name].attributes;primitive=[];const attributes={};for(const key in nodeDef)primitive.push(this.parser.getDependency("accessor",nodeDef[key]).then(accessor=>{attributes[key]=accessor;return attributes[key]}));
if(1>primitive.length)return null;primitive.push(this.parser.createNodeMesh(nodeIndex));return Promise.all(primitive).then(results=>{const nodeObject=results.pop();var meshes=nodeObject.isGroup?nodeObject.children:[nodeObject];results=results[0].count;const instancedMeshes=[];for(const mesh of meshes){meshes=new _three.Matrix4;const p=new _three.Vector3,q=new _three.Quaternion,s=new _three.Vector3(1,1,1),instancedMesh=new _three.InstancedMesh(mesh.geometry,mesh.material,results);for(let i=0;i<results;i++)attributes.TRANSLATION&&
p.fromBufferAttribute(attributes.TRANSLATION,i),attributes.ROTATION&&q.fromBufferAttribute(attributes.ROTATION,i),attributes.SCALE&&s.fromBufferAttribute(attributes.SCALE,i),instancedMesh.setMatrixAt(i,meshes.compose(p,q,s));for(const attributeName in attributes)"TRANSLATION"!==attributeName&&"ROTATION"!==attributeName&&"SCALE"!==attributeName&&mesh.geometry.setAttribute(attributeName,attributes[attributeName]);_three.Object3D.prototype.copy.call(instancedMesh,mesh);this.parser.assignFinalMaterial(instancedMesh);
instancedMeshes.push(instancedMesh)}return nodeObject.isGroup?(nodeObject.clear(),nodeObject.add(...instancedMeshes),nodeObject):instancedMeshes[0]})}}class GLTFBinaryExtension{constructor(data){this.name=EXTENSIONS.KHR_BINARY_GLTF;this.body=this.content=null;var headerView=new DataView(data,0,12);const textDecoder=new TextDecoder;this.header={magic:textDecoder.decode(new Uint8Array(data.slice(0,4))),version:headerView.getUint32(4,!0),length:headerView.getUint32(8,!0)};if("glTF"!==this.header.magic)throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
if(2>this.header.version)throw Error("THREE.GLTFLoader: Legacy binary file detected.");headerView=this.header.length-12;const chunkView=new DataView(data,12);let chunkIndex=0;for(;chunkIndex<headerView;){const chunkLength=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;var chunkType=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;1313821514===chunkType?(chunkType=new Uint8Array(data,12+chunkIndex,chunkLength),this.content=textDecoder.decode(chunkType)):5130562===chunkType&&(chunkType=12+chunkIndex,
this.body=data.slice(chunkType,chunkType+chunkLength));chunkIndex+=chunkLength}if(null===this.content)throw Error("THREE.GLTFLoader: JSON content not found.");}}class GLTFDracoMeshCompressionExtension{constructor(json,dracoLoader){if(!dracoLoader)throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;this.json=json;this.dracoLoader=dracoLoader;this.dracoLoader.preload()}decodePrimitive(primitive,parser){const json=this.json,dracoLoader=this.dracoLoader,
bufferViewIndex=primitive.extensions[this.name].bufferView,gltfAttributeMap=primitive.extensions[this.name].attributes,threeAttributeMap={},attributeNormalizedMap={},attributeTypeMap={};for(var attributeName$jscomp$0 in gltfAttributeMap){var threeAttributeName=ATTRIBUTES[attributeName$jscomp$0]||attributeName$jscomp$0.toLowerCase();threeAttributeMap[threeAttributeName]=gltfAttributeMap[attributeName$jscomp$0]}for(const attributeName in primitive.attributes)attributeName$jscomp$0=ATTRIBUTES[attributeName]||
attributeName.toLowerCase(),void 0!==gltfAttributeMap[attributeName]&&(threeAttributeName=json.accessors[primitive.attributes[attributeName]],attributeTypeMap[attributeName$jscomp$0]=WEBGL_COMPONENT_TYPES[threeAttributeName.componentType].name,attributeNormalizedMap[attributeName$jscomp$0]=!0===threeAttributeName.normalized);return parser.getDependency("bufferView",bufferViewIndex).then(function(bufferView){return new Promise(function(resolve){dracoLoader.decodeDracoFile(bufferView,function(geometry){for(const attributeName in geometry.attributes){const attribute=
geometry.attributes[attributeName],normalized=attributeNormalizedMap[attributeName];void 0!==normalized&&(attribute.normalized=normalized)}resolve(geometry)},threeAttributeMap,attributeTypeMap)})})}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(texture,transform){if((void 0===transform.texCoord||transform.texCoord===texture.channel)&&void 0===transform.offset&&void 0===transform.rotation&&void 0===transform.scale)return texture;texture=
texture.clone();void 0!==transform.texCoord&&(texture.channel=transform.texCoord);void 0!==transform.offset&&texture.offset.fromArray(transform.offset);void 0!==transform.rotation&&(texture.rotation=transform.rotation);void 0!==transform.scale&&texture.repeat.fromArray(transform.scale);texture.needsUpdate=!0;return texture}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends _three.Interpolant{constructor(parameterPositions,
sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,valueSize=this.valueSize;index=index*valueSize*3+valueSize;for(let i=0;i!==valueSize;i++)result[i]=values[index+i];return result}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,stride2=2*stride;var stride3=3*stride;t1-=t0;t0=(t-t0)/t1;t=t0*t0;var ppp=t*t0;i1*=stride3;
stride3=i1-stride3;const s2=-2*ppp+3*t;ppp-=t;const s0=1-s2;t0=ppp-t+t0;for(t=0;t!==stride;t++)result[t]=s0*values[stride3+t+stride]+t0*values[stride3+t+stride2]*t1+s2*values[i1+t+stride]+ppp*values[i1+t]*t1;return result}}const _q=new _three.Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(i1,t0,t,t1){i1=super.interpolate_(i1,t0,t,t1);_q.fromArray(i1).normalize().toArray(i1);return i1}}const WEBGL_CONSTANTS={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,
FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:_three.NearestFilter,9729:_three.LinearFilter,9984:_three.NearestMipmapNearestFilter,9985:_three.LinearMipmapNearestFilter,9986:_three.NearestMipmapLinearFilter,
9987:_three.LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:_three.ClampToEdgeWrapping,33648:_three.MirroredRepeatWrapping,10497:_three.RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION=
{CUBICSPLINE:void 0,LINEAR:_three.InterpolateLinear,STEP:_three.InterpolateDiscrete},_identityMatrix=new _three.Matrix4;class GLTFParser{constructor(json={},options={}){this.json=json;this.extensions={};this.plugins={};this.options=options;this.cache=new GLTFRegistry;this.associations=new Map;this.primitiveCache={};this.nodeCache={};this.meshCache={refs:{},uses:{}};this.cameraCache={refs:{},uses:{}};this.lightCache={refs:{},uses:{}};this.sourceCache={};this.textureCache={};this.nodeNamesUsed={};options=
json=!1;let firefoxVersion=-1;"undefined"!==typeof navigator&&(json=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),firefoxVersion=(options=-1<navigator.userAgent.indexOf("Firefox"))?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1);this.textureLoader="undefined"===typeof createImageBitmap||json||options&&98>firefoxVersion?new _three.TextureLoader(this.options.manager):new _three.ImageBitmapLoader(this.options.manager);this.textureLoader.setCrossOrigin(this.options.crossOrigin);
this.textureLoader.setRequestHeader(this.options.requestHeader);this.fileLoader=new _three.FileLoader(this.options.manager);this.fileLoader.setResponseType("arraybuffer");"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(extensions){this.extensions=extensions}setPlugins(plugins){this.plugins=plugins}parse(onLoad,onError){const parser=this,json=this.json,extensions=this.extensions;this.cache.removeAll();this.nodeCache={};this._invokeAll(function(ext){return ext._markDefs&&
ext._markDefs()});Promise.all(this._invokeAll(function(ext){return ext.beforeRoot&&ext.beforeRoot()})).then(function(){return Promise.all([parser.getDependencies("scene"),parser.getDependencies("animation"),parser.getDependencies("camera")])}).then(function(dependencies){const result={scene:dependencies[0][json.scene||0],scenes:dependencies[0],animations:dependencies[1],cameras:dependencies[2],asset:json.asset,parser,userData:{}};addUnknownExtensionsToUserData(extensions,result,json);assignExtrasToUserData(result,
json);Promise.all(parser._invokeAll(function(ext){return ext.afterRoot&&ext.afterRoot(result)})).then(function(){onLoad(result)})}).catch(onError)}_markDefs(){const nodeDefs=this.json.nodes||[];var skinDefs=this.json.skins||[];const meshDefs=this.json.meshes||[];for(let skinIndex=0,skinLength=skinDefs.length;skinIndex<skinLength;skinIndex++){const joints=skinDefs[skinIndex].joints;for(let i=0,il=joints.length;i<il;i++)nodeDefs[joints[i]].isBone=!0}for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<
nodeLength;nodeIndex++)skinDefs=nodeDefs[nodeIndex],void 0!==skinDefs.mesh&&(this._addNodeRef(this.meshCache,skinDefs.mesh),void 0!==skinDefs.skin&&(meshDefs[skinDefs.mesh].isSkinnedMesh=!0)),void 0!==skinDefs.camera&&this._addNodeRef(this.cameraCache,skinDefs.camera)}_addNodeRef(cache,index){void 0!==index&&(void 0===cache.refs[index]&&(cache.refs[index]=cache.uses[index]=0),cache.refs[index]++)}_getNodeRef(cache,index,object){if(1>=cache.refs[index])return object;const ref=object.clone(),updateMappings=
(original,clone)=>{const mappings=this.associations.get(original);null!=mappings&&this.associations.set(clone,mappings);for(const [i,child]of original.children.entries())updateMappings(child,clone.children[i])};updateMappings(object,ref);ref.name+="_instance_"+cache.uses[index]++;return ref}_invokeOne(func){const extensions=Object.values(this.plugins);extensions.push(this);for(let i=0;i<extensions.length;i++){const result=func(extensions[i]);if(result)return result}return null}_invokeAll(func){const extensions=
Object.values(this.plugins);extensions.unshift(this);const pending=[];for(let i=0;i<extensions.length;i++){const result=func(extensions[i]);result&&pending.push(result)}return pending}getDependency(type,index){const cacheKey=type+":"+index;let dependency=this.cache.get(cacheKey);if(!dependency){switch(type){case "scene":dependency=this.loadScene(index);break;case "node":dependency=this._invokeOne(function(ext){return ext.loadNode&&ext.loadNode(index)});break;case "mesh":dependency=this._invokeOne(function(ext){return ext.loadMesh&&
ext.loadMesh(index)});break;case "accessor":dependency=this.loadAccessor(index);break;case "bufferView":dependency=this._invokeOne(function(ext){return ext.loadBufferView&&ext.loadBufferView(index)});break;case "buffer":dependency=this.loadBuffer(index);break;case "material":dependency=this._invokeOne(function(ext){return ext.loadMaterial&&ext.loadMaterial(index)});break;case "texture":dependency=this._invokeOne(function(ext){return ext.loadTexture&&ext.loadTexture(index)});break;case "skin":dependency=
this.loadSkin(index);break;case "animation":dependency=this._invokeOne(function(ext){return ext.loadAnimation&&ext.loadAnimation(index)});break;case "camera":dependency=this.loadCamera(index);break;default:if(dependency=this._invokeOne(function(ext){return ext!=this&&ext.getDependency&&ext.getDependency(type,index)}),!dependency)throw Error("Unknown type: "+type);}this.cache.add(cacheKey,dependency)}return dependency}getDependencies(type){let dependencies=this.cache.get(type);if(!dependencies){const parser=
this;dependencies=Promise.all((this.json[type+("mesh"===type?"es":"s")]||[]).map(function(def,index){return parser.getDependency(type,index)}));this.cache.add(type,dependencies)}return dependencies}loadBuffer(bufferIndex){const bufferDef=this.json.buffers[bufferIndex],loader=this.fileLoader;if(bufferDef.type&&"arraybuffer"!==bufferDef.type)throw Error("THREE.GLTFLoader: "+bufferDef.type+" buffer type is not supported.");if(void 0===bufferDef.uri&&0===bufferIndex)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
const options=this.options;return new Promise(function(resolve,reject){loader.load(_three.LoaderUtils.resolveURL(bufferDef.uri,options.path),resolve,void 0,function(){reject(Error('THREE.GLTFLoader: Failed to load buffer "'+bufferDef.uri+'".'))})})}loadBufferView(bufferViewIndex){const bufferViewDef=this.json.bufferViews[bufferViewIndex];return this.getDependency("buffer",bufferViewDef.buffer).then(function(buffer){const byteOffset=bufferViewDef.byteOffset||0;return buffer.slice(byteOffset,byteOffset+
(bufferViewDef.byteLength||0))})}loadAccessor(accessorIndex){const parser=this,json=this.json,accessorDef=this.json.accessors[accessorIndex];if(void 0===accessorDef.bufferView&&void 0===accessorDef.sparse){accessorIndex=WEBGL_TYPE_SIZES[accessorDef.type];const normalized=!0===accessorDef.normalized,array=new WEBGL_COMPONENT_TYPES[accessorDef.componentType](accessorDef.count*accessorIndex);return Promise.resolve(new _three.BufferAttribute(array,accessorIndex,normalized))}accessorIndex=[];void 0!==
accessorDef.bufferView?accessorIndex.push(this.getDependency("bufferView",accessorDef.bufferView)):accessorIndex.push(null);void 0!==accessorDef.sparse&&(accessorIndex.push(this.getDependency("bufferView",accessorDef.sparse.indices.bufferView)),accessorIndex.push(this.getDependency("bufferView",accessorDef.sparse.values.bufferView)));return Promise.all(accessorIndex).then(function(bufferViews){var bufferView=bufferViews[0];const itemSize=WEBGL_TYPE_SIZES[accessorDef.type],TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType];
var elementBytes=TypedArray.BYTES_PER_ELEMENT,byteOffset=accessorDef.byteOffset||0,byteStride=void 0!==accessorDef.bufferView?json.bufferViews[accessorDef.bufferView].byteStride:void 0;const normalized=!0===accessorDef.normalized;if(byteStride&&byteStride!==elementBytes*itemSize){var array=Math.floor(byteOffset/byteStride);const ibCacheKey="InterleavedBuffer:"+accessorDef.bufferView+":"+accessorDef.componentType+":"+array+":"+accessorDef.count;let ib=parser.cache.get(ibCacheKey);ib||(array=new TypedArray(bufferView,
array*byteStride,accessorDef.count*byteStride/elementBytes),ib=new _three.InterleavedBuffer(array,byteStride/elementBytes),parser.cache.add(ibCacheKey,ib));elementBytes=new _three.InterleavedBufferAttribute(ib,itemSize,byteOffset%byteStride/elementBytes,normalized)}else array=null===bufferView?new TypedArray(accessorDef.count*itemSize):new TypedArray(bufferView,byteOffset,accessorDef.count*itemSize),elementBytes=new _three.BufferAttribute(array,itemSize,normalized);if(void 0!==accessorDef.sparse){byteStride=
accessorDef.sparse.values.byteOffset||0;byteOffset=new WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType](bufferViews[1],accessorDef.sparse.indices.byteOffset||0,accessorDef.sparse.count*WEBGL_TYPE_SIZES.SCALAR);bufferViews=new TypedArray(bufferViews[2],byteStride,accessorDef.sparse.count*itemSize);null!==bufferView&&(elementBytes=new _three.BufferAttribute(elementBytes.array.slice(),elementBytes.itemSize,elementBytes.normalized));for(let i=0,il=byteOffset.length;i<il;i++)if(bufferView=
byteOffset[i],elementBytes.setX(bufferView,bufferViews[i*itemSize]),2<=itemSize&&elementBytes.setY(bufferView,bufferViews[i*itemSize+1]),3<=itemSize&&elementBytes.setZ(bufferView,bufferViews[i*itemSize+2]),4<=itemSize&&elementBytes.setW(bufferView,bufferViews[i*itemSize+3]),5<=itemSize)throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");}return elementBytes})}loadTexture(textureIndex){var json=this.json,options=this.options;const sourceIndex=json.textures[textureIndex].source,
sourceDef=json.images[sourceIndex];json=this.textureLoader;sourceDef.uri&&(options=options.manager.getHandler(sourceDef.uri),null!==options&&(json=options));return this.loadTextureImage(textureIndex,sourceIndex,json)}loadTextureImage(textureIndex,sourceIndex,loader){const parser=this,json=this.json,textureDef=json.textures[textureIndex],sourceDef=json.images[sourceIndex],cacheKey=(sourceDef.uri||sourceDef.bufferView)+":"+textureDef.sampler;if(this.textureCache[cacheKey])return this.textureCache[cacheKey];
sourceIndex=this.loadImageSource(sourceIndex,loader).then(function(texture){texture.flipY=!1;texture.name=textureDef.name||sourceDef.name||"";""===texture.name&&"string"===typeof sourceDef.uri&&!1===sourceDef.uri.startsWith("data:image/")&&(texture.name=sourceDef.uri);const sampler=(json.samplers||{})[textureDef.sampler]||{};texture.magFilter=WEBGL_FILTERS[sampler.magFilter]||_three.LinearFilter;texture.minFilter=WEBGL_FILTERS[sampler.minFilter]||_three.LinearMipmapLinearFilter;texture.wrapS=WEBGL_WRAPPINGS[sampler.wrapS]||
_three.RepeatWrapping;texture.wrapT=WEBGL_WRAPPINGS[sampler.wrapT]||_three.RepeatWrapping;parser.associations.set(texture,{textures:textureIndex});return texture}).catch(function(){return null});return this.textureCache[cacheKey]=sourceIndex}loadImageSource(sourceIndex,loader){var json=this.json;const options=this.options;if(void 0!==this.sourceCache[sourceIndex])return this.sourceCache[sourceIndex].then(texture=>texture.clone());const sourceDef=json.images[sourceIndex],URL=self.URL||self.webkitURL;
let sourceURI=sourceDef.uri||"",isObjectURL=!1;if(void 0!==sourceDef.bufferView)sourceURI=this.getDependency("bufferView",sourceDef.bufferView).then(function(bufferView){isObjectURL=!0;bufferView=new Blob([bufferView],{type:sourceDef.mimeType});return sourceURI=URL.createObjectURL(bufferView)});else if(void 0===sourceDef.uri)throw Error("THREE.GLTFLoader: Image "+sourceIndex+" is missing URI and bufferView");json=Promise.resolve(sourceURI).then(function(sourceURI){return new Promise(function(resolve,
reject){let onLoad=resolve;!0===loader.isImageBitmapLoader&&(onLoad=function(imageBitmap){imageBitmap=new _three.Texture(imageBitmap);imageBitmap.needsUpdate=!0;resolve(imageBitmap)});loader.load(_three.LoaderUtils.resolveURL(sourceURI,options.path),onLoad,void 0,reject)})}).then(function(texture){!0===isObjectURL&&URL.revokeObjectURL(sourceURI);var JSCompiler_temp_const=texture.userData,JSCompiler_temp;(JSCompiler_temp=sourceDef.mimeType)||(JSCompiler_temp=sourceDef.uri,JSCompiler_temp=0<JSCompiler_temp.search(/\.jpe?g($|\?)/i)||
0===JSCompiler_temp.search(/^data:image\/jpeg/)?"image/jpeg":0<JSCompiler_temp.search(/\.webp($|\?)/i)||0===JSCompiler_temp.search(/^data:image\/webp/)?"image/webp":"image/png");JSCompiler_temp_const.mimeType=JSCompiler_temp;return texture}).catch(function(error){console.error("THREE.GLTFLoader: Couldn't load texture",sourceURI);throw error;});return this.sourceCache[sourceIndex]=json}assignTexture(materialParams,mapName,mapDef,encoding){const parser=this;return this.getDependency("texture",mapDef.index).then(function(texture){if(!texture)return null;
void 0!==mapDef.texCoord&&0<mapDef.texCoord&&(texture=texture.clone(),texture.channel=mapDef.texCoord);if(parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const transform=void 0!==mapDef.extensions?mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(transform){const gltfReference=parser.associations.get(texture);texture=parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture,transform);parser.associations.set(texture,gltfReference)}}void 0!==encoding&&(texture.encoding=
encoding);return materialParams[mapName]=texture})}assignFinalMaterial(mesh){var geometry=mesh.geometry;let material=mesh.material;const useDerivativeTangents=void 0===geometry.attributes.tangent,useVertexColors=void 0!==geometry.attributes.color;geometry=void 0===geometry.attributes.normal;if(mesh.isPoints){var cacheKey="PointsMaterial:"+material.uuid,pointsMaterial=this.cache.get(cacheKey);pointsMaterial||(pointsMaterial=new _three.PointsMaterial,_three.Material.prototype.copy.call(pointsMaterial,
material),pointsMaterial.color.copy(material.color),pointsMaterial.map=material.map,pointsMaterial.sizeAttenuation=!1,this.cache.add(cacheKey,pointsMaterial));material=pointsMaterial}else mesh.isLine&&(cacheKey="LineBasicMaterial:"+material.uuid,pointsMaterial=this.cache.get(cacheKey),pointsMaterial||(pointsMaterial=new _three.LineBasicMaterial,_three.Material.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),pointsMaterial.map=material.map,this.cache.add(cacheKey,
pointsMaterial)),material=pointsMaterial);if(useDerivativeTangents||useVertexColors||geometry)cacheKey="ClonedMaterial:"+material.uuid+":",useDerivativeTangents&&(cacheKey+="derivative-tangents:"),useVertexColors&&(cacheKey+="vertex-colors:"),geometry&&(cacheKey+="flat-shading:"),pointsMaterial=this.cache.get(cacheKey),pointsMaterial||(pointsMaterial=material.clone(),useVertexColors&&(pointsMaterial.vertexColors=!0),geometry&&(pointsMaterial.flatShading=!0),useDerivativeTangents&&(pointsMaterial.normalScale&&
(pointsMaterial.normalScale.y*=-1),pointsMaterial.clearcoatNormalScale&&(pointsMaterial.clearcoatNormalScale.y*=-1)),this.cache.add(cacheKey,pointsMaterial),this.associations.set(pointsMaterial,this.associations.get(material))),material=pointsMaterial;mesh.material=material}getMaterialType(){return _three.MeshStandardMaterial}loadMaterial(materialIndex){const parser=this,extensions=this.extensions,materialDef=this.json.materials[materialIndex];let materialType;const materialParams={},pending=[];if((materialDef.extensions||
{})[EXTENSIONS.KHR_MATERIALS_UNLIT]){var kmuExtension=extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];materialType=kmuExtension.getMaterialType();pending.push(kmuExtension.extendParams(materialParams,materialDef,parser))}else{kmuExtension=materialDef.pbrMetallicRoughness||{};materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;if(Array.isArray(kmuExtension.baseColorFactor)){const array=kmuExtension.baseColorFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==
kmuExtension.baseColorTexture&&pending.push(parser.assignTexture(materialParams,"map",kmuExtension.baseColorTexture,_three.sRGBEncoding));materialParams.metalness=void 0!==kmuExtension.metallicFactor?kmuExtension.metallicFactor:1;materialParams.roughness=void 0!==kmuExtension.roughnessFactor?kmuExtension.roughnessFactor:1;void 0!==kmuExtension.metallicRoughnessTexture&&(pending.push(parser.assignTexture(materialParams,"metalnessMap",kmuExtension.metallicRoughnessTexture)),pending.push(parser.assignTexture(materialParams,
"roughnessMap",kmuExtension.metallicRoughnessTexture)));materialType=this._invokeOne(function(ext){return ext.getMaterialType&&ext.getMaterialType(materialIndex)});pending.push(Promise.all(this._invokeAll(function(ext){return ext.extendMaterialParams&&ext.extendMaterialParams(materialIndex,materialParams)})))}!0===materialDef.doubleSided&&(materialParams.side=_three.DoubleSide);kmuExtension=materialDef.alphaMode||"OPAQUE";"BLEND"===kmuExtension?(materialParams.transparent=!0,materialParams.depthWrite=
!1):(materialParams.transparent=!1,"MASK"===kmuExtension&&(materialParams.alphaTest=void 0!==materialDef.alphaCutoff?materialDef.alphaCutoff:.5));void 0!==materialDef.normalTexture&&materialType!==_three.MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,"normalMap",materialDef.normalTexture)),materialParams.normalScale=new _three.Vector2(1,1),void 0!==materialDef.normalTexture.scale&&(kmuExtension=materialDef.normalTexture.scale,materialParams.normalScale.set(kmuExtension,kmuExtension)));
void 0!==materialDef.occlusionTexture&&materialType!==_three.MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,"aoMap",materialDef.occlusionTexture)),void 0!==materialDef.occlusionTexture.strength&&(materialParams.aoMapIntensity=materialDef.occlusionTexture.strength));void 0!==materialDef.emissiveFactor&&materialType!==_three.MeshBasicMaterial&&(materialParams.emissive=(new _three.Color).fromArray(materialDef.emissiveFactor));void 0!==materialDef.emissiveTexture&&materialType!==
_three.MeshBasicMaterial&&pending.push(parser.assignTexture(materialParams,"emissiveMap",materialDef.emissiveTexture,_three.sRGBEncoding));return Promise.all(pending).then(function(){const material=new materialType(materialParams);materialDef.name&&(material.name=materialDef.name);assignExtrasToUserData(material,materialDef);parser.associations.set(material,{materials:materialIndex});materialDef.extensions&&addUnknownExtensionsToUserData(extensions,material,materialDef);return material})}createUniqueName(originalName){let name=
originalName=_three.PropertyBinding.sanitizeNodeName(originalName||"");for(let i=1;this.nodeNamesUsed[name];++i)name=originalName+"_"+i;this.nodeNamesUsed[name]=!0;return name}loadGeometries(primitives){function createDracoPrimitive(primitive){return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive,parser).then(function(geometry){return addPrimitiveAttributes(geometry,primitive,parser)})}const parser=this,extensions=this.extensions,cache=this.primitiveCache,pending=[];for(let i=
0,il=primitives.length;i<il;i++){const primitive=primitives[i],cacheKey=createPrimitiveKey(primitive);var cached=cache[cacheKey];cached?pending.push(cached.promise):(cached=primitive.extensions&&primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?createDracoPrimitive(primitive):addPrimitiveAttributes(new _three.BufferGeometry,primitive,parser),cache[cacheKey]={primitive,promise:cached},pending.push(cached))}return Promise.all(pending)}loadMesh(meshIndex){const parser=this,extensions=this.extensions,
meshDef$jscomp$0=this.json.meshes[meshIndex],primitives=meshDef$jscomp$0.primitives,pending=[];for(let i=0,il=primitives.length;i<il;i++){const material=void 0===primitives[i].material?createDefaultMaterial(this.cache):this.getDependency("material",primitives[i].material);pending.push(material)}pending.push(parser.loadGeometries(primitives));return Promise.all(pending).then(function(results){var materials=results.slice(0,results.length-1);const geometries=results[results.length-1];results=[];for(let i$jscomp$0=
0,il$jscomp$0=geometries.length;i$jscomp$0<il$jscomp$0;i$jscomp$0++){var geometry=geometries[i$jscomp$0];const primitive=primitives[i$jscomp$0];var mesh=void 0;mesh=materials[i$jscomp$0];if(primitive.mode===WEBGL_CONSTANTS.TRIANGLES||primitive.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||primitive.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||void 0===primitive.mode)mesh=!0===meshDef$jscomp$0.isSkinnedMesh?new _three.SkinnedMesh(geometry,mesh):new _three.Mesh(geometry,mesh),!0===mesh.isSkinnedMesh&&mesh.normalizeSkinWeights(),
primitive.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP?mesh.geometry=(0,_BufferGeometryUtils.toTrianglesDrawMode)(mesh.geometry,_three.TriangleStripDrawMode):primitive.mode===WEBGL_CONSTANTS.TRIANGLE_FAN&&(mesh.geometry=(0,_BufferGeometryUtils.toTrianglesDrawMode)(mesh.geometry,_three.TriangleFanDrawMode));else if(primitive.mode===WEBGL_CONSTANTS.LINES)mesh=new _three.LineSegments(geometry,mesh);else if(primitive.mode===WEBGL_CONSTANTS.LINE_STRIP)mesh=new _three.Line(geometry,mesh);else if(primitive.mode===
WEBGL_CONSTANTS.LINE_LOOP)mesh=new _three.LineLoop(geometry,mesh);else if(primitive.mode===WEBGL_CONSTANTS.POINTS)mesh=new _three.Points(geometry,mesh);else throw Error("THREE.GLTFLoader: Primitive mode unsupported: "+primitive.mode);if(0<Object.keys(mesh.geometry.morphAttributes).length){geometry=mesh;var meshDef=meshDef$jscomp$0;geometry.updateMorphTargets();if(void 0!==meshDef.weights)for(let i=0,il=meshDef.weights.length;i<il;i++)geometry.morphTargetInfluences[i]=meshDef.weights[i];if(meshDef.extras&&
Array.isArray(meshDef.extras.targetNames))if(meshDef=meshDef.extras.targetNames,geometry.morphTargetInfluences.length===meshDef.length){geometry.morphTargetDictionary={};for(let i=0,il=meshDef.length;i<il;i++)geometry.morphTargetDictionary[meshDef[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}mesh.name=parser.createUniqueName(meshDef$jscomp$0.name||"mesh_"+meshIndex);assignExtrasToUserData(mesh,meshDef$jscomp$0);primitive.extensions&&addUnknownExtensionsToUserData(extensions,
mesh,primitive);parser.assignFinalMaterial(mesh);results.push(mesh)}for(let i=0,il=results.length;i<il;i++)parser.associations.set(results[i],{meshes:meshIndex,primitives:i});if(1===results.length)return results[0];materials=new _three.Group;parser.associations.set(materials,{meshes:meshIndex});for(let i=0,il=results.length;i<il;i++)materials.add(results[i]);return materials})}loadCamera(cameraIndex){let camera;cameraIndex=this.json.cameras[cameraIndex];const params=cameraIndex[cameraIndex.type];
if(params)return"perspective"===cameraIndex.type?camera=new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov),params.aspectRatio||1,params.znear||1,params.zfar||2E6):"orthographic"===cameraIndex.type&&(camera=new _three.OrthographicCamera(-params.xmag,params.xmag,params.ymag,-params.ymag,params.znear,params.zfar)),cameraIndex.name&&(camera.name=this.createUniqueName(cameraIndex.name)),assignExtrasToUserData(camera,cameraIndex),Promise.resolve(camera);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(skinIndex){const skinDef=
this.json.skins[skinIndex];skinIndex=[];for(let i=0,il=skinDef.joints.length;i<il;i++)skinIndex.push(this._loadNodeShallow(skinDef.joints[i]));void 0!==skinDef.inverseBindMatrices?skinIndex.push(this.getDependency("accessor",skinDef.inverseBindMatrices)):skinIndex.push(null);return Promise.all(skinIndex).then(function(results){const inverseBindMatrices=results.pop(),bones=[],boneInverses=[];for(let i=0,il=results.length;i<il;i++){var jointNode=results[i];jointNode?(bones.push(jointNode),jointNode=
new _three.Matrix4,null!==inverseBindMatrices&&jointNode.fromArray(inverseBindMatrices.array,16*i),boneInverses.push(jointNode)):console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',skinDef.joints[i])}return new _three.Skeleton(bones,boneInverses)})}loadAnimation(animationIndex){const animationDef=this.json.animations[animationIndex],animationName=animationDef.name?animationDef.name:"animation_"+animationIndex;animationIndex=[];const pendingInputAccessors=[],pendingOutputAccessors=[],pendingSamplers=
[],pendingTargets=[];for(let i=0,il=animationDef.channels.length;i<il;i++){var channel=animationDef.channels[i];const sampler=animationDef.samplers[channel.sampler];channel=channel.target;const input=void 0!==animationDef.parameters?animationDef.parameters[sampler.input]:sampler.input,output=void 0!==animationDef.parameters?animationDef.parameters[sampler.output]:sampler.output;void 0!==channel.node&&(animationIndex.push(this.getDependency("node",channel.node)),pendingInputAccessors.push(this.getDependency("accessor",
input)),pendingOutputAccessors.push(this.getDependency("accessor",output)),pendingSamplers.push(sampler),pendingTargets.push(channel))}return Promise.all([Promise.all(animationIndex),Promise.all(pendingInputAccessors),Promise.all(pendingOutputAccessors),Promise.all(pendingSamplers),Promise.all(pendingTargets)]).then(function(dependencies){const nodes=dependencies[0],inputAccessors=dependencies[1],outputAccessors=dependencies[2],samplers=dependencies[3];dependencies=dependencies[4];const tracks=[];
for(let i=0,il=nodes.length;i<il;i++){var node=nodes[i];const inputAccessor=inputAccessors[i];var outputAccessor=outputAccessors[i];const sampler=samplers[i],target=dependencies[i];if(void 0===node)continue;node.updateMatrix();let TypedKeyframeTrack;switch(PATH_PROPERTIES[target.path]){case PATH_PROPERTIES.weights:TypedKeyframeTrack=_three.NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:TypedKeyframeTrack=_three.QuaternionKeyframeTrack;break;default:TypedKeyframeTrack=_three.VectorKeyframeTrack}var targetName=
node.name?node.name:node.uuid;const interpolation=void 0!==sampler.interpolation?INTERPOLATION[sampler.interpolation]:_three.InterpolateLinear,targetNames=[];PATH_PROPERTIES[target.path]===PATH_PROPERTIES.weights?node.traverse(function(object){object.morphTargetInfluences&&targetNames.push(object.name?object.name:object.uuid)}):targetNames.push(targetName);node=outputAccessor.array;if(outputAccessor.normalized){outputAccessor=getNormalizedComponentScale(node.constructor);targetName=new Float32Array(node.length);
for(let j=0,jl=node.length;j<jl;j++)targetName[j]=node[j]*outputAccessor;node=targetName}for(let j=0,jl=targetNames.length;j<jl;j++)outputAccessor=new TypedKeyframeTrack(targetNames[j]+"."+PATH_PROPERTIES[target.path],inputAccessor.array,node,interpolation),"CUBICSPLINE"===sampler.interpolation&&(outputAccessor.createInterpolant=function(result){return new (this instanceof _three.QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant)(this.times,this.values,this.getValueSize()/
3,result)},outputAccessor.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),tracks.push(outputAccessor)}return new _three.AnimationClip(animationName,void 0,tracks)})}createNodeMesh(nodeIndex){const parser=this,nodeDef=this.json.nodes[nodeIndex];return void 0===nodeDef.mesh?null:parser.getDependency("mesh",nodeDef.mesh).then(function(mesh){mesh=parser._getNodeRef(parser.meshCache,nodeDef.mesh,mesh);void 0!==nodeDef.weights&&mesh.traverse(function(o){if(o.isMesh)for(let i=0,il=nodeDef.weights.length;i<
il;i++)o.morphTargetInfluences[i]=nodeDef.weights[i]});return mesh})}loadNode(nodeIndex){var nodeDef=this.json.nodes[nodeIndex];nodeIndex=this._loadNodeShallow(nodeIndex);const childPending=[],childrenDef=nodeDef.children||[];for(let i=0,il=childrenDef.length;i<il;i++)childPending.push(this.getDependency("node",childrenDef[i]));nodeDef=void 0===nodeDef.skin?Promise.resolve(null):this.getDependency("skin",nodeDef.skin);return Promise.all([nodeIndex,Promise.all(childPending),nodeDef]).then(function(results){const node=
results[0],children=results[1],skeleton=results[2];null!==skeleton&&node.traverse(function(mesh){mesh.isSkinnedMesh&&mesh.bind(skeleton,_identityMatrix)});for(let i=0,il=children.length;i<il;i++)node.add(children[i]);return node})}_loadNodeShallow(nodeIndex){const extensions=this.extensions,parser=this;if(void 0!==this.nodeCache[nodeIndex])return this.nodeCache[nodeIndex];const nodeDef=this.json.nodes[nodeIndex],nodeName=nodeDef.name?parser.createUniqueName(nodeDef.name):"",pending=[],meshPromise=
parser._invokeOne(function(ext){return ext.createNodeMesh&&ext.createNodeMesh(nodeIndex)});meshPromise&&pending.push(meshPromise);void 0!==nodeDef.camera&&pending.push(parser.getDependency("camera",nodeDef.camera).then(function(camera){return parser._getNodeRef(parser.cameraCache,nodeDef.camera,camera)}));parser._invokeAll(function(ext){return ext.createNodeAttachment&&ext.createNodeAttachment(nodeIndex)}).forEach(function(promise){pending.push(promise)});this.nodeCache[nodeIndex]=Promise.all(pending).then(function(objects){let node;
node=!0===nodeDef.isBone?new _three.Bone:1<objects.length?new _three.Group:1===objects.length?objects[0]:new _three.Object3D;if(node!==objects[0])for(let i=0,il=objects.length;i<il;i++)node.add(objects[i]);nodeDef.name&&(node.userData.name=nodeDef.name,node.name=nodeName);assignExtrasToUserData(node,nodeDef);nodeDef.extensions&&addUnknownExtensionsToUserData(extensions,node,nodeDef);void 0!==nodeDef.matrix?(objects=new _three.Matrix4,objects.fromArray(nodeDef.matrix),node.applyMatrix4(objects)):(void 0!==
nodeDef.translation&&node.position.fromArray(nodeDef.translation),void 0!==nodeDef.rotation&&node.quaternion.fromArray(nodeDef.rotation),void 0!==nodeDef.scale&&node.scale.fromArray(nodeDef.scale));parser.associations.has(node)||parser.associations.set(node,{});parser.associations.get(node).nodes=nodeIndex;return node});return this.nodeCache[nodeIndex]}loadScene(sceneIndex){var extensions=this.extensions;sceneIndex=this.json.scenes[sceneIndex];const parser=this,scene=new _three.Group;sceneIndex.name&&
(scene.name=parser.createUniqueName(sceneIndex.name));assignExtrasToUserData(scene,sceneIndex);sceneIndex.extensions&&addUnknownExtensionsToUserData(extensions,scene,sceneIndex);extensions=sceneIndex.nodes||[];sceneIndex=[];for(let i=0,il=extensions.length;i<il;i++)sceneIndex.push(parser.getDependency("node",extensions[i]));return Promise.all(sceneIndex).then(function(nodes){for(let i=0,il=nodes.length;i<il;i++)scene.add(nodes[i]);parser.associations=(node$jscomp$0=>{const reducedAssociations=new Map;
for(const [key,value]of parser.associations)(key instanceof _three.Material||key instanceof _three.Texture)&&reducedAssociations.set(key,value);node$jscomp$0.traverse(node=>{const mappings=parser.associations.get(node);null!=mappings&&reducedAssociations.set(node,mappings)});return reducedAssociations})(scene);return scene})}}}
//# sourceMappingURL=module$node_modules$three$examples$jsm$loaders$GLTFLoader.js.map
