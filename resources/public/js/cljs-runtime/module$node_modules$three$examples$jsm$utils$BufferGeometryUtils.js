shadow$provide.module$node_modules$three$examples$jsm$utils$BufferGeometryUtils=function(global,require,module,exports){function mergeGeometries(geometries,useGroups=!1){var isIndexed=null!==geometries[0].index,attributesUsed=new Set(Object.keys(geometries[0].attributes)),morphAttributesUsed=new Set(Object.keys(geometries[0].morphAttributes)),attributes={};const morphAttributes={};var morphTargetsRelative=geometries[0].morphTargetsRelative;const mergedGeometry=new _three.BufferGeometry;let offset=
0;for(let i=0;i<geometries.length;++i){var geometry=geometries[i];let attributesCount=0;if(isIndexed!==(null!==geometry.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const name in geometry.attributes){if(!attributesUsed.has(name))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+
i+'. All geometries must have compatible attributes; make sure "'+name+'" attribute exists among all geometries, or in none of them.'),null;void 0===attributes[name]&&(attributes[name]=[]);attributes[name].push(geometry.attributes[name]);attributesCount++}if(attributesCount!==attributesUsed.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(morphTargetsRelative!==geometry.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+
i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const name in geometry.morphAttributes){if(!morphAttributesUsed.has(name))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===morphAttributes[name]&&(morphAttributes[name]=[]);morphAttributes[name].push(geometry.morphAttributes[name])}if(useGroups){if(isIndexed)geometry=geometry.index.count;
else if(void 0!==geometry.attributes.position)geometry=geometry.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;mergedGeometry.addGroup(offset,geometry,i);offset+=geometry}}if(isIndexed){useGroups=0;isIndexed=[];for(attributesUsed=0;attributesUsed<geometries.length;++attributesUsed){morphAttributesUsed=geometries[attributesUsed].index;for(morphTargetsRelative=
0;morphTargetsRelative<morphAttributesUsed.count;++morphTargetsRelative)isIndexed.push(morphAttributesUsed.getX(morphTargetsRelative)+useGroups);useGroups+=geometries[attributesUsed].attributes.position.count}mergedGeometry.setIndex(isIndexed)}for(var name$jscomp$0 in attributes){geometries=mergeAttributes(attributes[name$jscomp$0]);if(!geometries)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+name$jscomp$0+" attribute."),null;mergedGeometry.setAttribute(name$jscomp$0,
geometries)}for(const name in morphAttributes){attributes=morphAttributes[name][0].length;if(0===attributes)break;mergedGeometry.morphAttributes=mergedGeometry.morphAttributes||{};mergedGeometry.morphAttributes[name]=[];for(name$jscomp$0=0;name$jscomp$0<attributes;++name$jscomp$0){geometries=[];for(useGroups=0;useGroups<morphAttributes[name].length;++useGroups)geometries.push(morphAttributes[name][useGroups][name$jscomp$0]);geometries=mergeAttributes(geometries);if(!geometries)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+
name+" morphAttribute."),null;mergedGeometry.morphAttributes[name].push(geometries)}}return mergedGeometry}function mergeAttributes(attributes){let itemSize,normalized;var arrayLength=0;for(var i=0;i<attributes.length;++i){const attribute=attributes[i];if(attribute.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===TypedArray)var TypedArray=attribute.array.constructor;if(TypedArray!==
attribute.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;void 0===itemSize&&(itemSize=attribute.itemSize);if(itemSize!==attribute.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;void 0===normalized&&(normalized=attribute.normalized);if(normalized!==
attribute.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;arrayLength+=attribute.array.length}TypedArray=new TypedArray(arrayLength);arrayLength=0;for(i=0;i<attributes.length;++i)TypedArray.set(attributes[i].array,arrayLength),arrayLength+=attributes[i].array.length;return new _three.BufferAttribute(TypedArray,itemSize,normalized)}function deinterleaveAttribute(attribute){const count=
attribute.count,itemSize=attribute.itemSize;var normalized=attribute.normalized,array=new attribute.data.array.constructor(count*itemSize);normalized=attribute.isInstancedInterleavedBufferAttribute?new _three.InstancedBufferAttribute(array,itemSize,normalized,attribute.meshPerAttribute):new _three.BufferAttribute(array,itemSize,normalized);for(array=0;array<count;array++)normalized.setX(array,attribute.getX(array)),2<=itemSize&&normalized.setY(array,attribute.getY(array)),3<=itemSize&&normalized.setZ(array,
attribute.getZ(array)),4<=itemSize&&normalized.setW(array,attribute.getW(array));return normalized}Object.defineProperty(exports,"__esModule",{value:!0});exports.deepCloneAttribute=function(attribute){return attribute.isInstancedInterleavedBufferAttribute||attribute.isInterleavedBufferAttribute?deinterleaveAttribute(attribute):attribute.isInstancedBufferAttribute?(new _three.InstancedBufferAttribute).copy(attribute):(new _three.BufferAttribute).copy(attribute)};exports.deinterleaveAttribute=deinterleaveAttribute;
exports.deinterleaveGeometry=function(geometry){var attributes=geometry.attributes;geometry=geometry.morphTargets;const attrMap=new Map;for(const key in attributes){const attr=attributes[key];attr.isInterleavedBufferAttribute&&(attrMap.has(attr)||attrMap.set(attr,deinterleaveAttribute(attr)),attributes[key]=attrMap.get(attr))}for(const key in geometry)attributes=geometry[key],attributes.isInterleavedBufferAttribute&&(attrMap.has(attributes)||attrMap.set(attributes,deinterleaveAttribute(attributes)),
geometry[key]=attrMap.get(attributes))};exports.computeMikkTSpaceTangents=function(geometry,MikkTSpace,negateSign=!0){function getAttributeArray(attribute){if(attribute.normalized||attribute.isInterleavedBufferAttribute){const dstArray=new Float32Array(attribute.getCount()*attribute.itemSize);for(let i=0,j=0;i<attribute.getCount();i++)dstArray[j++]=attribute.getX(i),dstArray[j++]=attribute.getY(i),2<attribute.itemSize&&(dstArray[j++]=attribute.getZ(i));return dstArray}return attribute.array instanceof
Float32Array?attribute.array:new Float32Array(attribute.array)}if(!MikkTSpace||!MikkTSpace.isReady)throw Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!geometry.hasAttribute("position")||!geometry.hasAttribute("normal")||!geometry.hasAttribute("uv"))throw Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');const _geometry=geometry.index?geometry.toNonIndexed():geometry;MikkTSpace=MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position),
getAttributeArray(_geometry.attributes.normal),getAttributeArray(_geometry.attributes.uv));if(negateSign)for(negateSign=3;negateSign<MikkTSpace.length;negateSign+=4)MikkTSpace[negateSign]*=-1;_geometry.setAttribute("tangent",new _three.BufferAttribute(MikkTSpace,4));geometry!==_geometry&&geometry.copy(_geometry);return geometry};exports.mergeGeometries=mergeGeometries;exports.mergeBufferGeometries=function(geometries,useGroups=!1){console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().");
return mergeGeometries(geometries,useGroups)};exports.mergeAttributes=mergeAttributes;exports.mergeBufferAttributes=function(attributes){console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().");return mergeAttributes(attributes)};exports.interleaveAttributes=function(attributes){var arrayLength=0,stride=0;for(let i=0,l=attributes.length;i<l;++i){var attribute$jscomp$0=attributes[i];if(void 0===TypedArray)var TypedArray=attribute$jscomp$0.array.constructor;
if(TypedArray!==attribute$jscomp$0.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;arrayLength+=attribute$jscomp$0.array.length;stride+=attribute$jscomp$0.itemSize}TypedArray=new _three.InterleavedBuffer(new TypedArray(arrayLength),stride);arrayLength=0;stride=[];attribute$jscomp$0=["getX","getY","getZ","getW"];const setters=["setX","setY","setZ","setW"];for(let j=0,l=attributes.length;j<l;j++){const attribute=attributes[j],itemSize=attribute.itemSize,
count=attribute.count,iba=new _three.InterleavedBufferAttribute(TypedArray,itemSize,arrayLength,attribute.normalized);stride.push(iba);arrayLength+=itemSize;for(let c=0;c<count;c++)for(let k=0;k<itemSize;k++)iba[setters[k]](c,attribute[attribute$jscomp$0[k]](c))}return stride};exports.estimateBytesUsed=function(geometry){let mem=0;for(const name in geometry.attributes){const attr=geometry.getAttribute(name);mem+=attr.count*attr.itemSize*attr.array.BYTES_PER_ELEMENT}geometry=geometry.getIndex();return mem+=
geometry?geometry.count*geometry.itemSize*geometry.array.BYTES_PER_ELEMENT:0};exports.mergeVertices=function(geometry,tolerance=1E-4){tolerance=Math.max(tolerance,Number.EPSILON);var hashToIndex={},indices=geometry.getIndex(),positions=geometry.getAttribute("position");const vertexCount=indices?indices.count:positions.count;positions=0;const attributeNames=Object.keys(geometry.attributes),tmpAttributes={},tmpMorphAttributes={},newIndices=[],getters=["getX","getY","getZ","getW"],setters=["setX","setY",
"setZ","setW"];for(let i=0,l=attributeNames.length;i<l;i++){var name$jscomp$0=attributeNames[i],attr=geometry.attributes[name$jscomp$0];tmpAttributes[name$jscomp$0]=new _three.BufferAttribute(new attr.array.constructor(attr.count*attr.itemSize),attr.itemSize,attr.normalized);(attr=geometry.morphAttributes[name$jscomp$0])&&(tmpMorphAttributes[name$jscomp$0]=new _three.BufferAttribute(new attr.array.constructor(attr.count*attr.itemSize),attr.itemSize,attr.normalized))}tolerance=Math.pow(10,Math.log10(1/
tolerance));for(name$jscomp$0=0;name$jscomp$0<vertexCount;name$jscomp$0++){attr=indices?indices.getX(name$jscomp$0):name$jscomp$0;let hash="";for(let j=0,l=attributeNames.length;j<l;j++){var attribute=geometry.getAttribute(attributeNames[j]),itemSize=attribute.itemSize;for(var k$jscomp$0=0;k$jscomp$0<itemSize;k$jscomp$0++)hash+=`${~~(attribute[getters[k$jscomp$0]](attr)*tolerance)},`}if(hash in hashToIndex)newIndices.push(hashToIndex[hash]);else{for(let j=0,l=attributeNames.length;j<l;j++){var name$jscomp$1=
attributeNames[j];attribute=geometry.getAttribute(name$jscomp$1);itemSize=geometry.morphAttributes[name$jscomp$1];k$jscomp$0=attribute.itemSize;const newarray=tmpAttributes[name$jscomp$1];name$jscomp$1=tmpMorphAttributes[name$jscomp$1];for(let k=0;k<k$jscomp$0;k++){const getterFunc=getters[k],setterFunc=setters[k];newarray[setterFunc](positions,attribute[getterFunc](attr));if(itemSize)for(let m=0,ml=itemSize.length;m<ml;m++)name$jscomp$1[m][setterFunc](positions,itemSize[m][getterFunc](attr))}}hashToIndex[hash]=
positions;newIndices.push(positions);positions++}}hashToIndex=geometry.clone();for(const name in geometry.attributes)if(geometry=tmpAttributes[name],hashToIndex.setAttribute(name,new _three.BufferAttribute(geometry.array.slice(0,positions*geometry.itemSize),geometry.itemSize,geometry.normalized)),name in tmpMorphAttributes)for(geometry=0;geometry<tmpMorphAttributes[name].length;geometry++)indices=tmpMorphAttributes[name][geometry],hashToIndex.morphAttributes[name][geometry]=new _three.BufferAttribute(indices.array.slice(0,
positions*indices.itemSize),indices.itemSize,indices.normalized);hashToIndex.setIndex(newIndices);return hashToIndex};exports.toTrianglesDrawMode=function(geometry,drawMode){if(drawMode===_three.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),geometry;if(drawMode===_three.TriangleFanDrawMode||drawMode===_three.TriangleStripDrawMode){var index=geometry.getIndex();if(null===index){var indices=[];index=geometry.getAttribute("position");
if(void 0!==index){for(var i=0;i<index.count;i++)indices.push(i);geometry.setIndex(indices);index=geometry.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),geometry}i=index.count-2;indices=[];if(drawMode===_three.TriangleFanDrawMode)for(drawMode=1;drawMode<=i;drawMode++)indices.push(index.getX(0)),indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1));else for(drawMode=0;drawMode<i;drawMode++)0===
drawMode%2?(indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode+2))):(indices.push(index.getX(drawMode+2)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode)));indices.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");geometry=geometry.clone();geometry.setIndex(indices);geometry.clearGroups();return geometry}console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
drawMode);return geometry};exports.computeMorphedAttributes=function(object$jscomp$0){function _calculateMorphedAttributeData(object,attribute,morphAttribute,morphTargetsRelative,a,b,c,modifiedAttributeArray){_vA.fromBufferAttribute(attribute,a);_vB.fromBufferAttribute(attribute,b);_vC.fromBufferAttribute(attribute,c);attribute=object.morphTargetInfluences;if(morphAttribute&&attribute){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(let i=0,il=morphAttribute.length;i<il;i++){const influence=
attribute[i],morph=morphAttribute[i];0!==influence&&(_tempA.fromBufferAttribute(morph,a),_tempB.fromBufferAttribute(morph,b),_tempC.fromBufferAttribute(morph,c),morphTargetsRelative?(_morphA.addScaledVector(_tempA,influence),_morphB.addScaledVector(_tempB,influence),_morphC.addScaledVector(_tempC,influence)):(_morphA.addScaledVector(_tempA.sub(_vA),influence),_morphB.addScaledVector(_tempB.sub(_vB),influence),_morphC.addScaledVector(_tempC.sub(_vC),influence)))}_vA.add(_morphA);_vB.add(_morphB);_vC.add(_morphC)}object.isSkinnedMesh&&
(object.applyBoneTransform(a,_vA),object.applyBoneTransform(b,_vB),object.applyBoneTransform(c,_vC));modifiedAttributeArray[3*a]=_vA.x;modifiedAttributeArray[3*a+1]=_vA.y;modifiedAttributeArray[3*a+2]=_vA.z;modifiedAttributeArray[3*b]=_vB.x;modifiedAttributeArray[3*b+1]=_vB.y;modifiedAttributeArray[3*b+2]=_vB.z;modifiedAttributeArray[3*c]=_vC.x;modifiedAttributeArray[3*c+1]=_vC.y;modifiedAttributeArray[3*c+2]=_vC.z}const _vA=new _three.Vector3,_vB=new _three.Vector3,_vC=new _three.Vector3,_tempA=
new _three.Vector3,_tempB=new _three.Vector3,_tempC=new _three.Vector3,_morphA=new _three.Vector3,_morphB=new _three.Vector3,_morphC=new _three.Vector3;var geometry=object$jscomp$0.geometry,material=object$jscomp$0.material;let b$jscomp$0,c$jscomp$0;var index=geometry.index;const positionAttribute=geometry.attributes.position,morphPosition=geometry.morphAttributes.position,morphTargetsRelative$jscomp$0=geometry.morphTargetsRelative,normalAttribute=geometry.attributes.normal,morphNormal=geometry.morphAttributes.position,
groups=geometry.groups,drawRange=geometry.drawRange;let il$jscomp$0,jl;const modifiedPosition=new Float32Array(positionAttribute.count*positionAttribute.itemSize);geometry=new Float32Array(normalAttribute.count*normalAttribute.itemSize);if(null!==index)if(Array.isArray(material))for(material=0,il$jscomp$0=groups.length;material<il$jscomp$0;material++){var a$jscomp$0=groups[material];var j=Math.max(a$jscomp$0.start,drawRange.start);for(jl=a$jscomp$0=Math.min(a$jscomp$0.start+a$jscomp$0.count,drawRange.start+
drawRange.count);j<jl;j+=3)a$jscomp$0=index.getX(j),b$jscomp$0=index.getX(j+1),c$jscomp$0=index.getX(j+2),_calculateMorphedAttributeData(object$jscomp$0,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,geometry)}else for(j=Math.max(0,drawRange.start),a$jscomp$0=Math.min(index.count,drawRange.start+
drawRange.count),material=j,il$jscomp$0=a$jscomp$0;material<il$jscomp$0;material+=3)a$jscomp$0=index.getX(material),b$jscomp$0=index.getX(material+1),c$jscomp$0=index.getX(material+2),_calculateMorphedAttributeData(object$jscomp$0,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,geometry);else if(Array.isArray(material))for(material=
0,il$jscomp$0=groups.length;material<il$jscomp$0;material++)for(a$jscomp$0=groups[material],j=Math.max(a$jscomp$0.start,drawRange.start),jl=a$jscomp$0=Math.min(a$jscomp$0.start+a$jscomp$0.count,drawRange.start+drawRange.count);j<jl;j+=3)a$jscomp$0=j,b$jscomp$0=j+1,c$jscomp$0=j+2,_calculateMorphedAttributeData(object$jscomp$0,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,normalAttribute,
morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,geometry);else for(j=Math.max(0,drawRange.start),a$jscomp$0=Math.min(positionAttribute.count,drawRange.start+drawRange.count),material=j,il$jscomp$0=a$jscomp$0;material<il$jscomp$0;material+=3)a$jscomp$0=material,b$jscomp$0=material+1,c$jscomp$0=material+2,_calculateMorphedAttributeData(object$jscomp$0,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,
normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,geometry);object$jscomp$0=new _three.Float32BufferAttribute(modifiedPosition,3);index=new _three.Float32BufferAttribute(geometry,3);return{positionAttribute,normalAttribute,morphedPositionAttribute:object$jscomp$0,morphedNormalAttribute:index}};exports.mergeGroups=function(geometry){if(0===geometry.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),
geometry;let groups=geometry.groups;groups=groups.sort((a,b)=>a.materialIndex!==b.materialIndex?a.materialIndex-b.materialIndex:a.start-b.start);if(null===geometry.getIndex()){var positionAttribute=geometry.getAttribute("position"),indices=[];for(var i=0;i<positionAttribute.count;i+=3)indices.push(i,i+1,i+2);geometry.setIndex(indices)}positionAttribute=geometry.getIndex();indices=[];for(i=0;i<groups.length;i++){var group=groups[i],groupStart=group.start;for(group=groupStart+group.count;groupStart<
group;groupStart++)indices.push(positionAttribute.getX(groupStart))}geometry.dispose();geometry.setIndex(indices);positionAttribute=0;for(indices=0;indices<groups.length;indices++)i=groups[indices],i.start=positionAttribute,positionAttribute+=i.count;positionAttribute=groups[0];geometry.groups=[positionAttribute];for(indices=1;indices<groups.length;indices++)i=groups[indices],positionAttribute.materialIndex===i.materialIndex?positionAttribute.count+=i.count:(positionAttribute=i,geometry.groups.push(positionAttribute));
return geometry};exports.toCreasedNormals=function(geometry,creaseAngle=Math.PI/3){function hashVertex(v){return`${~~(v.x*hashMultiplier)},${~~(v.y*hashMultiplier)},${~~(v.z*hashMultiplier)}`}creaseAngle=Math.cos(creaseAngle);const hashMultiplier=100*(1+1E-10),verts=[new _three.Vector3,new _three.Vector3,new _three.Vector3],tempVec1=new _three.Vector3,tempVec2=new _three.Vector3,tempNorm=new _three.Vector3,tempNorm2=new _three.Vector3;geometry=geometry.toNonIndexed();const posAttr=geometry.attributes.position,
vertexMap={};for(let i=0,l=posAttr.count/3;i<l;i++){var i3=3*i,a=verts[0].fromBufferAttribute(posAttr,i3+0),b=verts[1].fromBufferAttribute(posAttr,i3+1);i3=verts[2].fromBufferAttribute(posAttr,i3+2);tempVec1.subVectors(i3,b);tempVec2.subVectors(a,b);a=(new _three.Vector3).crossVectors(tempVec1,tempVec2).normalize();for(b=0;3>b;b++)i3=hashVertex(verts[b]),i3 in vertexMap||(vertexMap[i3]=[]),vertexMap[i3].push(a)}a=new Float32Array(3*posAttr.count);a=new _three.BufferAttribute(a,3,!1);for(let i=0,l=
posAttr.count/3;i<l;i++){b=3*i;i3=verts[0].fromBufferAttribute(posAttr,b+0);var b$jscomp$0=verts[1].fromBufferAttribute(posAttr,b+1),c=verts[2].fromBufferAttribute(posAttr,b+2);tempVec1.subVectors(c,b$jscomp$0);tempVec2.subVectors(i3,b$jscomp$0);tempNorm.crossVectors(tempVec1,tempVec2).normalize();for(i3=0;3>i3;i3++){b$jscomp$0=hashVertex(verts[i3]);b$jscomp$0=vertexMap[b$jscomp$0];tempNorm2.set(0,0,0);for(let k=0,lk=b$jscomp$0.length;k<lk;k++)c=b$jscomp$0[k],tempNorm.dot(c)>creaseAngle&&tempNorm2.add(c);
tempNorm2.normalize();a.setXYZ(b+i3,tempNorm2.x,tempNorm2.y,tempNorm2.z)}}geometry.setAttribute("normal",a);return geometry};var _three=require("module$node_modules$three$build$three")}
//# sourceMappingURL=module$node_modules$three$examples$jsm$utils$BufferGeometryUtils.js.map
