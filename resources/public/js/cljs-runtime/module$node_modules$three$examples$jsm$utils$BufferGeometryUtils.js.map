{
"version":3,
"file":"module$node_modules$three$examples$jsm$utils$BufferGeometryUtils.js",
"lineCount":43,
"mappings":"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",
"sources":["node_modules/three/examples/jsm/utils/BufferGeometryUtils.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$examples$jsm$utils$BufferGeometryUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deepCloneAttribute = deepCloneAttribute;\nexports.deinterleaveAttribute = deinterleaveAttribute;\nexports.deinterleaveGeometry = deinterleaveGeometry;\nexports.computeMikkTSpaceTangents = computeMikkTSpaceTangents;\nexports.mergeGeometries = mergeGeometries;\nexports.mergeBufferGeometries = mergeBufferGeometries;\nexports.mergeAttributes = mergeAttributes;\nexports.mergeBufferAttributes = mergeBufferAttributes;\nexports.interleaveAttributes = interleaveAttributes;\nexports.estimateBytesUsed = estimateBytesUsed;\nexports.mergeVertices = mergeVertices;\nexports.toTrianglesDrawMode = toTrianglesDrawMode;\nexports.computeMorphedAttributes = computeMorphedAttributes;\nexports.mergeGroups = mergeGroups;\nexports.toCreasedNormals = toCreasedNormals;\n\nvar _three = require(\"three\");\n\nfunction computeMikkTSpaceTangents(geometry, MikkTSpace, negateSign = true) {\n  if (!MikkTSpace || !MikkTSpace.isReady) {\n    throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');\n  }\n\n  if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {\n    throw new Error('BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.');\n  }\n\n  function getAttributeArray(attribute) {\n    if (attribute.normalized || attribute.isInterleavedBufferAttribute) {\n      const dstArray = new Float32Array(attribute.getCount() * attribute.itemSize);\n\n      for (let i = 0, j = 0; i < attribute.getCount(); i++) {\n        dstArray[j++] = attribute.getX(i);\n        dstArray[j++] = attribute.getY(i);\n\n        if (attribute.itemSize > 2) {\n          dstArray[j++] = attribute.getZ(i);\n        }\n      }\n\n      return dstArray;\n    }\n\n    if (attribute.array instanceof Float32Array) {\n      return attribute.array;\n    }\n\n    return new Float32Array(attribute.array);\n  } // MikkTSpace algorithm requires non-indexed input.\n\n\n  const _geometry = geometry.index ? geometry.toNonIndexed() : geometry; // Compute vertex tangents.\n\n\n  const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv)); // Texture coordinate convention of glTF differs from the apparent\n  // default of the MikkTSpace library; .w component must be flipped.\n\n  if (negateSign) {\n    for (let i = 3; i < tangents.length; i += 4) {\n      tangents[i] *= -1;\n    }\n  } //\n\n\n  _geometry.setAttribute('tangent', new _three.BufferAttribute(tangents, 4));\n\n  if (geometry !== _geometry) {\n    geometry.copy(_geometry);\n  }\n\n  return geometry;\n}\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\n\n\nfunction mergeGeometries(geometries, useGroups = false) {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new _three.BufferGeometry();\n  let offset = 0;\n\n  for (let i = 0; i < geometries.length; ++i) {\n    const geometry = geometries[i];\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geometry.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n\n    for (const name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === undefined) attributes[name] = [];\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n\n    if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n\n    for (const name in geometry.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n      morphAttributes[name].push(geometry.morphAttributes[name]);\n    }\n\n    if (useGroups) {\n      let count;\n\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  } // merge indices\n\n\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n\n    for (let i = 0; i < geometries.length; ++i) {\n      const index = geometries[i].index;\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geometries[i].attributes.position.count;\n    }\n\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n\n  for (const name in attributes) {\n    const mergedAttribute = mergeAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n\n  for (const name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n\n      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\n\n\nfunction mergeAttributes(attributes) {\n  let TypedArray;\n  let itemSize;\n  let normalized;\n  let arrayLength = 0;\n\n  for (let i = 0; i < attributes.length; ++i) {\n    const attribute = attributes[i];\n\n    if (attribute.isInterleavedBufferAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.');\n      return null;\n    }\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n\n    if (itemSize === undefined) itemSize = attribute.itemSize;\n\n    if (itemSize !== attribute.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n\n    if (normalized === undefined) normalized = attribute.normalized;\n\n    if (normalized !== attribute.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n  }\n\n  const array = new TypedArray(arrayLength);\n  let offset = 0;\n\n  for (let i = 0; i < attributes.length; ++i) {\n    array.set(attributes[i].array, offset);\n    offset += attributes[i].array.length;\n  }\n\n  return new _three.BufferAttribute(array, itemSize, normalized);\n}\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\n\n\nfunction deepCloneAttribute(attribute) {\n  if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {\n    return deinterleaveAttribute(attribute);\n  }\n\n  if (attribute.isInstancedBufferAttribute) {\n    return new _three.InstancedBufferAttribute().copy(attribute);\n  }\n\n  return new _three.BufferAttribute().copy(attribute);\n}\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\n\n\nfunction interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray;\n  let arrayLength = 0;\n  let stride = 0; // calculate the length and type of the interleavedBuffer\n\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n\n\n  const interleavedBuffer = new _three.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new _three.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        iba[setters[k]](c, attribute[getters[k]](c));\n      }\n    }\n  }\n\n  return res;\n} // returns a new, non-interleaved version of the provided attribute\n\n\nfunction deinterleaveAttribute(attribute) {\n  const cons = attribute.data.array.constructor;\n  const count = attribute.count;\n  const itemSize = attribute.itemSize;\n  const normalized = attribute.normalized;\n  const array = new cons(count * itemSize);\n  let newAttribute;\n\n  if (attribute.isInstancedInterleavedBufferAttribute) {\n    newAttribute = new _three.InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute);\n  } else {\n    newAttribute = new _three.BufferAttribute(array, itemSize, normalized);\n  }\n\n  for (let i = 0; i < count; i++) {\n    newAttribute.setX(i, attribute.getX(i));\n\n    if (itemSize >= 2) {\n      newAttribute.setY(i, attribute.getY(i));\n    }\n\n    if (itemSize >= 3) {\n      newAttribute.setZ(i, attribute.getZ(i));\n    }\n\n    if (itemSize >= 4) {\n      newAttribute.setW(i, attribute.getW(i));\n    }\n  }\n\n  return newAttribute;\n} // deinterleaves all attributes on the geometry\n\n\nfunction deinterleaveGeometry(geometry) {\n  const attributes = geometry.attributes;\n  const morphTargets = geometry.morphTargets;\n  const attrMap = new Map();\n\n  for (const key in attributes) {\n    const attr = attributes[key];\n\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n\n      attributes[key] = attrMap.get(attr);\n    }\n  }\n\n  for (const key in morphTargets) {\n    const attr = morphTargets[key];\n\n    if (attr.isInterleavedBufferAttribute) {\n      if (!attrMap.has(attr)) {\n        attrMap.set(attr, deinterleaveAttribute(attr));\n      }\n\n      morphTargets[key] = attrMap.get(attr);\n    }\n  }\n}\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\n\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0;\n\n  for (const name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\n\n\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute('position');\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  let nextIndex = 0; // attributes and new attribute arrays\n\n  const attributeNames = Object.keys(geometry.attributes);\n  const tmpAttributes = {};\n  const tmpMorphAttributes = {};\n  const newIndices = [];\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\n  const setters = ['setX', 'setY', 'setZ', 'setW']; // Initialize the arrays, allocating space conservatively. Extra\n  // space will be trimmed in the last step.\n\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const attr = geometry.attributes[name];\n    tmpAttributes[name] = new _three.BufferAttribute(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);\n    const morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      tmpMorphAttributes[name] = new _three.BufferAttribute(new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize), morphAttr.itemSize, morphAttr.normalized);\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    let hash = '';\n\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the temporary attributes\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = tmpAttributes[name];\n        const newMorphArrays = tmpMorphAttributes[name];\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          const setterFunc = setters[k];\n          newarray[setterFunc](nextIndex, attribute[getterFunc](index));\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m][setterFunc](nextIndex, morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // generate result BufferGeometry\n\n\n  const result = geometry.clone();\n\n  for (const name in geometry.attributes) {\n    const tmpAttribute = tmpAttributes[name];\n    result.setAttribute(name, new _three.BufferAttribute(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));\n    if (!(name in tmpMorphAttributes)) continue;\n\n    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {\n      const tmpMorphAttribute = tmpMorphAttributes[name][j];\n      result.morphAttributes[name][j] = new _three.BufferAttribute(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);\n    }\n  } // indices\n\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === _three.TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n\n  if (drawMode === _three.TriangleFanDrawMode || drawMode === _three.TriangleStripDrawMode) {\n    let index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n\n    if (drawMode === _three.TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n      for (let i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n      for (let i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\n\n\nfunction computeMorphedAttributes(object) {\n  const _vA = new _three.Vector3();\n\n  const _vB = new _three.Vector3();\n\n  const _vC = new _three.Vector3();\n\n  const _tempA = new _three.Vector3();\n\n  const _tempB = new _three.Vector3();\n\n  const _tempC = new _three.Vector3();\n\n  const _morphA = new _three.Vector3();\n\n  const _morphB = new _three.Vector3();\n\n  const _morphC = new _three.Vector3();\n\n  function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n\n    _vB.fromBufferAttribute(attribute, b);\n\n    _vC.fromBufferAttribute(attribute, c);\n\n    const morphInfluences = object.morphTargetInfluences;\n\n    if (morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morph = morphAttribute[i];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a);\n\n        _tempB.fromBufferAttribute(morph, b);\n\n        _tempC.fromBufferAttribute(morph, c);\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object.isSkinnedMesh) {\n      object.applyBoneTransform(a, _vA);\n      object.applyBoneTransform(b, _vB);\n      object.applyBoneTransform(c, _vC);\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new _three.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new _three.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\n\nfunction mergeGroups(geometry) {\n  if (geometry.groups.length === 0) {\n    console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');\n    return geometry;\n  }\n\n  let groups = geometry.groups; // sort groups by material index\n\n  groups = groups.sort((a, b) => {\n    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;\n    return a.start - b.start;\n  }); // create index for non-indexed geometries\n\n  if (geometry.getIndex() === null) {\n    const positionAttribute = geometry.getAttribute('position');\n    const indices = [];\n\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      indices.push(i, i + 1, i + 2);\n    }\n\n    geometry.setIndex(indices);\n  } // sort index\n\n\n  const index = geometry.getIndex();\n  const newIndices = [];\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    const groupStart = group.start;\n    const groupLength = groupStart + group.count;\n\n    for (let j = groupStart; j < groupLength; j++) {\n      newIndices.push(index.getX(j));\n    }\n  }\n\n  geometry.dispose(); // Required to force buffer recreation\n\n  geometry.setIndex(newIndices); // update groups indices\n\n  let start = 0;\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    group.start = start;\n    start += group.count;\n  } // merge groups\n\n\n  let currentGroup = groups[0];\n  geometry.groups = [currentGroup];\n\n  for (let i = 1; i < groups.length; i++) {\n    const group = groups[i];\n\n    if (currentGroup.materialIndex === group.materialIndex) {\n      currentGroup.count += group.count;\n    } else {\n      currentGroup = group;\n      geometry.groups.push(currentGroup);\n    }\n  }\n\n  return geometry;\n} // Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\n\n\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3\n/* 60 degrees */\n) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 1e2; // reusable vertors\n\n  const verts = [new _three.Vector3(), new _three.Vector3(), new _three.Vector3()];\n  const tempVec1 = new _three.Vector3();\n  const tempVec2 = new _three.Vector3();\n  const tempNorm = new _three.Vector3();\n  const tempNorm2 = new _three.Vector3(); // hashes a vector\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  const resultGeometry = geometry.toNonIndexed();\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {}; // find all the normals shared by commonly located vertices\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b); // add the normal to the map for all vertices\n\n    const normal = new _three.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n\n      vertexMap[hash].push(normal);\n    }\n  } // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n\n\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new _three.BufferAttribute(normalArray, 3, false);\n\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize(); // average all normals that meet the threshold and set the normal value\n\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr);\n  return resultGeometry;\n}\n\nfunction mergeBufferGeometries(geometries, useGroups = false) {\n  console.warn('THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().'); // @deprecated, r151\n\n  return mergeGeometries(geometries, useGroups);\n}\n\nfunction mergeBufferAttributes(attributes) {\n  console.warn('THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().'); // @deprecated, r151\n\n  return mergeAttributes(attributes);\n}\n};"],
"names":["shadow$provide","global","require","module","exports","mergeGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","_three","BufferGeometry","offset","i","length","geometry","attributesCount","console","error","name","has","undefined","push","size","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeAttributes","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","TypedArray","array","constructor","set","BufferAttribute","deinterleaveAttribute","data","newAttribute","isInstancedInterleavedBufferAttribute","InstancedBufferAttribute","meshPerAttribute","setX","setY","getY","setZ","getZ","setW","getW","defineProperty","value","deepCloneAttribute","isInstancedBufferAttribute","copy","deinterleaveGeometry","morphTargets","attrMap","Map","key","attr","get","computeMikkTSpaceTangents","MikkTSpace","negateSign","getAttributeArray","dstArray","Float32Array","getCount","isReady","Error","hasAttribute","_geometry","toNonIndexed","tangents","generateTangents","normal","uv","mergeBufferGeometries","warn","mergeBufferAttributes","interleaveAttributes","stride","l","interleavedBuffer","InterleavedBuffer","res","getters","setters","iba","InterleavedBufferAttribute","c","k","estimateBytesUsed","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","tmpAttributes","tmpMorphAttributes","newIndices","morphAttr","shiftMultiplier","pow","log10","decimalShift","hash","newarray","newMorphArrays","getterFunc","setterFunc","m","ml","result","clone","tmpAttribute","slice","tmpMorphAttribute","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","_calculateMorphedAttributeData","morphAttribute","a","b","modifiedAttributeArray","_vA","fromBufferAttribute","_vB","_vC","morphInfluences","morphTargetInfluences","_morphA","_morphB","_morphC","il","influence","morph","_tempA","_tempB","_tempC","addScaledVector","sub","add","isSkinnedMesh","applyBoneTransform","x","y","z","Vector3","material","positionAttribute","morphPosition","normalAttribute","morphNormal","groups","drawRange","jl","modifiedPosition","modifiedNormal","Array","isArray","group","start","end","min","morphedPositionAttribute","Float32BufferAttribute","morphedNormalAttribute","mergeGroups","sort","materialIndex","groupStart","groupLength","dispose","currentGroup","toCreasedNormals","creaseAngle","PI","hashVertex","v","hashMultiplier","creaseDot","cos","verts","tempVec1","tempVec2","tempNorm","tempNorm2","resultGeometry","posAttr","vertexMap","i3","subVectors","crossVectors","normalize","n","vert","normalArray","normAttr","otherNormals","lk","otherNorm","dot","setXYZ"]
}
