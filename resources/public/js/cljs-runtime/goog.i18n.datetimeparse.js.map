{
"version":3,
"file":"goog.i18n.datetimeparse.js",
"lineCount":548,
"mappings":"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",
"sources":["goog/i18n/datetimeparse.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Date/Time parsing library with locale support.\n */\n\n\n/**\n * Namespace for locale date/time parsing functions\n */\ngoog.provide('goog.i18n.DateTimeParse');\n\ngoog.require('goog.asserts');\ngoog.require('goog.date');\ngoog.require('goog.i18n.DateTimeFormat.Format');\ngoog.require('goog.i18n.DateTimeSymbols');\ngoog.require('goog.i18n.DayPeriods');\ngoog.require('goog.object');\ngoog.requireType('goog.i18n.DateTimeSymbolsType');\n\ngoog.scope(function() {\n// For referencing modules\nconst DayPeriods = goog.module.get('goog.i18n.DayPeriods');\n\n/**\n * DateTimeParse is for parsing date in a locale-sensitive manner. It allows\n * user to use any customized patterns to parse date-time string under certain\n * locale. Things varies across locales like month name, weekname, field\n * order, etc.\n *\n * This module is the counter-part of DateTimeFormat. They use the same\n * date/time pattern specification, which is borrowed from ICU/JDK.\n *\n * This implementation could parse partial date/time.\n *\n * Time Format Syntax: To specify the time format use a time pattern string.\n * In this pattern, the following letters are reserved as pattern letters, which\n * are defined as follows:\n *\n * ```\n * Symbol   Meaning                 Presentation        Example\n * ------   -------                 ------------        -------\n * G?       era designator          (Text)              AD\n * y#       year                    (Number)            1996\n * M        month in year           (Text & Number)     July & 07\n * L        standalone month in year (Text & Number)    July & 07\n * d?       day in month            (Number)            10\n * h?       hour in am/pm (1~12)    (Number)            12\n * H?       hour in day (0~23)      (Number)            0\n * m?       minute in hour          (Number)            30\n * s?       second in minute        (Number)            55\n * S?       fractional second       (Number)            978\n * E        day of week             (Text)              Tuesday\n * D*       day in year             (Number)            189\n * a?       am/pm marker            (Text)              PM\n * b?#      am/pm/noon/midnight     (Text)              Noon\n * B?#      flexible day periods    (Text)              de l\u2019apr\u00e8s-midi'\n * k        hour in day (1~24)      (Number)            24\n * K        hour in am/pm (0~11)    (Number)            0\n * z?#      time zone               (Text)              Pacific Standard Time\n * Z?       time zone (RFC 822)     (Number) -0800\n * v?#      time zone (generic)     (Text)              Pacific Time\n * '        escape for text         (Delimiter)         'Date='\n * ''       single quote            (Literal)           'o''clock'\n * ```\n *\n * - Items marked with '*' are not supported yet.\n * - Items marked with '#' work different from java (i.e. may not support\n *   parsing more verbose formats/examples, such as \"Noon\" or \"Pacific Time\").\n * - Items marked with '?' can be omitted when at the end of a non-empty format\n *   string. Optional text items can also be omitted when abutting immediately\n *   before or after a numeric item (i.e. \"Gy\" and \"yG\" will both accept \"1\").\n *\n * The letter count and presentation together determine the accepted formats:\n * - **Text**: both full and abbreviated forms are allowed, with the long form\n *   being preferred.\n * - **Number**: the count indicates the maximum number of characters parsed in\n *   case of abutting numbers (the count is otherwise ignored, except for the\n *   special case of 'yy', discussed below).\n * - **Text & Number**: count of 3 or more requires the text form, otherwise\n *   allows either number or text.\n *\n * Any letters not in the above table should be treated as _reserved_: any\n * alphanumeric characters that must be matched literally should be wrapped in\n * single quotes to ensure any newly added format characters don't change the\n * meaning.  Punctuation (such as ':', '.', ' ', '#' and '@') may be left\n * unquoted and will still be treated as literals.\n *\n * Examples Using the US Locale:\n *\n * ```\n * Format Pattern                         Result\n * --------------                         -------\n * \"yyyy.MM.dd G 'at' HH:mm:ss vvvv\" ->>  1996.07.10 AD at 15:08:56 Pacific Time\n * \"EEE, MMM d, ''yy\"                ->>  Wed, July 10, '96\n * \"h:mm a\"                          ->>  12:08 PM\n * \"hh 'o''clock' a, zzzz\"           ->>  12 o'clock PM, Pacific Daylight Time\n * \"K:mm a, vvv\"                     ->>  0:00 PM, PT\n * \"yyyyy.MMMMM.dd GGG hh:mm aaa\"    ->>  01996.July.10 AD 12:08 PM\n * ```\n *\n * <p> When parsing a date string using the abbreviated year pattern (\"yy\"),\n * DateTimeParse must interpret the abbreviated year relative to some\n * century. It does this by adjusting dates to be within 80 years before and 20\n * years after the time the parse function is called. For example, using a\n * pattern of \"MM/dd/yy\" and a DateTimeParse instance created on Jan 1, 1997,\n * the string \"01/11/12\" would be interpreted as Jan 11, 2012 while the string\n * \"05/04/64\" would be interpreted as May 4, 1964. During parsing, only\n * strings consisting of exactly two digits, as defined by {@link\n * java.lang.Character#isDigit(char)}, will be parsed into the default\n * century. Any other numeric string, such as a one digit string, a three or\n * more digit string will be interpreted as its face value.\n *\n * <p> If the year pattern does not have exactly two 'y' characters, the year is\n * interpreted literally, regardless of the number of digits. So when using the\n * patterns \"MM/dd/yyyy\" or \"M/D/y\", \"01/11/12\" parses to Jan 11, 12 A.D.\n *\n * <p> When numeric fields abut one another directly, with no intervening\n * delimiter characters, they constitute a run of abutting numeric fields. Such\n * runs are parsed specially. For example, the format \"HHmmss\" parses the input\n * text \"123456\" to 12:34:56, parses the input text \"12345\" to 1:23:45, and\n * fails to parse \"1234\". In other words, the leftmost field of the run is\n * flexible (i.e. it may be shorter), while the others keep a fixed width. If\n * the parse fails anywhere in the run, then the leftmost field is shortened by\n * one character, and the entire run is parsed again. This is repeated until\n * either the parse succeeds or the leftmost field is one character in length.\n * If the parse still fails at that point, the parse of the run fails.\n *\n * <p> Now timezone parsing only support GMT:hhmm, GMT:+hhmm, GMT:-hhmm\n */\n\n/**\n * Components of patternParts_ object.\n * @private @typedef {{\n *    text: (string|undefined),\n *    count: (number),\n *    numeric: (boolean|undefined),\n *    abutStart: (boolean|undefined),\n * }}\n */\ngoog.i18n.DateTimeParse.PatternPart;\n\n// To match one white horizontal space character at start of string, including\n// non-ASCII.\nconst horizontalWhiteSpacePrefixRegex =\n    /^[ \\t\\xA0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000]/;\n// Match one or more white space, including those covered by JavaScript's \\s\n// match.\nconst skipWhiteSpacePrefixRegex =\n    /^[\\s\\xA0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000]+/;\n\n/**\n * Construct a DateTimeParse based on current locale.\n * @param {string|number} pattern pattern specification or pattern type.\n * @param {!Object=} opt_dateTimeSymbols Optional symbols to use for this\n *     instance rather than the global symbols.\n * @constructor\n * @final\n */\ngoog.i18n.DateTimeParse = function(pattern, opt_dateTimeSymbols) {\n  'use strict';\n  goog.asserts.assert(\n      opt_dateTimeSymbols !== undefined ||\n          goog.i18n.DateTimeSymbols !== undefined,\n      'goog.i18n.DateTimeSymbols or explicit symbols must be defined');\n\n  /** @const @private {!Array<!goog.i18n.DateTimeParse.PatternPart>}; */\n  this.patternParts_ = [];\n\n  /**\n   * Data structure with all the locale info needed for date formatting.\n   * (day/month names, most common patterns, rules for week-end, etc.)\n   * @const @private {!goog.i18n.DateTimeSymbolsType}\n   */\n  this.dateTimeSymbols_ = /** @type {!goog.i18n.DateTimeSymbolsType} */ (\n      opt_dateTimeSymbols || goog.i18n.DateTimeSymbols);\n  if (typeof pattern == 'number') {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n\n\n/**\n * Number of years prior to now that the century used to\n * disambiguate two digit years will begin\n *\n * @type {number}\n */\ngoog.i18n.DateTimeParse.ambiguousYearCenturyStart = 80;\n\n\n/**\n * All acceptable pattern characters.\n * @private\n * @const\n */\ngoog.i18n.DateTimeParse.PATTERN_CHARS_ = 'GyMdkHmsSEDabBhKzZvQL';\n\n\n/**\n * Pattern characters that specify numerical field.\n * @private\n * @const\n */\ngoog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_ = 'MydhHmsSDkK';\n\n\n/**\n * Pattern characters supported by predictive parsing.\n * @private\n * @const\n */\ngoog.i18n.DateTimeParse.PREDICTIVE_FORMAT_CHARS_ = 'abBhHkKm';\n\n\n/**\n * Apply a pattern to this Parser. The pattern string will be parsed and saved\n * in \"compiled\" form.\n * Note: this method is somewhat similar to the pattern parsing method in\n *       datetimeformat. If you see something wrong here, you might want\n *       to check the other.\n * @param {string} pattern It describes the format of date string that need to\n *     be parsed.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.applyPattern_ = function(pattern) {\n  'use strict';\n  let inQuote = false;\n  let buf = '';\n\n  for (let i = 0; i < pattern.length; i++) {\n    const ch = pattern.charAt(i);\n\n    // handle space, add literal part (if exist), and add space part\n    if (ch == ' ') {\n      if (buf.length > 0) {\n        this.patternParts_.push(\n            {text: buf, count: 0, abutStart: false, numeric: false});\n        buf = '';\n      }\n      this.patternParts_.push(\n          {text: ' ', count: 0, abutStart: false, numeric: false});\n      while (i < pattern.length - 1 && pattern.charAt(i + 1) == ' ') {\n        i++;\n      }\n    } else if (inQuote) {\n      // inside quote, except '', just copy or exit\n      if (ch == '\\'') {\n        if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\\'') {\n          // quote appeared twice continuously, interpret as one quote.\n          buf += '\\'';\n          i++;\n        } else {\n          // exit quote\n          inQuote = false;\n        }\n      } else {\n        // literal\n        buf += ch;\n      }\n    } else if (goog.i18n.DateTimeParse.PATTERN_CHARS_.indexOf(ch) >= 0) {\n      // outside quote, it is a pattern char\n      if (buf.length > 0) {\n        this.patternParts_.push(\n            {text: buf, count: 0, abutStart: false, numeric: false});\n        buf = '';\n      }\n      const count = this.getNextCharCount_(pattern, i);\n      const numeric = this.isNumericField_(ch, count);\n      this.patternParts_.push(\n          {text: ch, count: count, abutStart: false, numeric: numeric});\n      i += count - 1;\n    } else if (ch == '\\'') {\n      // Two consecutive quotes is a quote literal, inside or outside of quotes.\n      if (i + 1 < pattern.length && pattern.charAt(i + 1) == '\\'') {\n        buf += '\\'';\n        i++;\n      } else {\n        inQuote = true;\n      }\n    } else {\n      buf += ch;\n    }\n  }\n\n  if (buf.length > 0) {\n    this.patternParts_.push(\n        {text: buf, count: 0, abutStart: false, numeric: false});\n  }\n\n  this.markAbutStart_();\n};\n\n\n/**\n * Apply a predefined pattern to this Parser.\n * @param {number} formatType A constant used to identified the predefined\n *     pattern string stored in locale repository.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.applyStandardPattern_ = function(formatType) {\n  'use strict';\n  let pattern;\n  // formatType constants are in consecutive numbers. So it can be used to\n  // index array in following way.\n\n  // if type is out of range, default to medium date/time format.\n  if (formatType > goog.i18n.DateTimeFormat.Format.SHORT_DATETIME) {\n    formatType = goog.i18n.DateTimeFormat.Format.MEDIUM_DATETIME;\n  }\n\n  if (formatType < 4) {\n    pattern = this.dateTimeSymbols_.DATEFORMATS[formatType];\n  } else if (formatType < 8) {\n    pattern = this.dateTimeSymbols_.TIMEFORMATS[formatType - 4];\n  } else {\n    pattern = this.dateTimeSymbols_.DATETIMEFORMATS[formatType - 8];\n    pattern = pattern.replace(\n        '{1}', this.dateTimeSymbols_.DATEFORMATS[formatType - 8]);\n    pattern = pattern.replace(\n        '{0}', this.dateTimeSymbols_.TIMEFORMATS[formatType - 8]);\n  }\n  this.applyPattern_(pattern);\n};\n\n\n/**\n * Calculate character repeat count in pattern.\n *\n * @param {string} pattern It describes the format of date string that need to\n *     be parsed.\n * @param {number} start The position of pattern character.\n *\n * @return {number} Repeat count.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.getNextCharCount_ = function(pattern, start) {\n  'use strict';\n  const ch = pattern.charAt(start);\n  let next = start + 1;\n  while (next < pattern.length && pattern.charAt(next) == ch) {\n    next++;\n  }\n  return next - start;\n};\n\n\n/**\n * Identify the start of an abutting numeric fields' run. Taking pattern\n * \"HHmmss\" as an example. It will try to parse 2/2/2 characters of the input\n * text, then if that fails, 1/2/2. We only adjust the width of the leftmost\n * field; the others remain fixed. This allows \"123456\" => 12:34:56, but\n * \"12345\" => 1:23:45. Likewise, for the pattern \"yyyyMMdd\" we try 4/2/2,\n * 3/2/2, 2/2/2, and finally 1/2/2. The first field of connected numeric\n * fields will be marked as abutStart, its width can be reduced to accommodate\n * others.\n *\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.markAbutStart_ = function() {\n  'use strict';\n  // abut parts are continuous numeric parts. abutStart is the switch\n  // point from non-abut to abut\n  let abut = false;\n\n  for (let i = 0; i < this.patternParts_.length; i++) {\n    if (this.patternParts_[i].numeric) {\n      // if next part is not following abut sequence, and is numeric\n      if (!abut && i + 1 < this.patternParts_.length &&\n          this.patternParts_[i + 1].numeric) {\n        abut = true;\n        this.patternParts_[i].abutStart = true;\n      }\n    } else {\n      abut = false;\n    }\n  }\n};\n\n\n/**\n * Check if the pattern part is a numeric field.\n *\n * @param {string} ch pattern character\n * @param {number} count pattern character count\n *\n * @return {boolean} true if the pattern part is numeric field.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.isNumericField_ = function(ch, count) {\n  'use strict';\n  if (count <= 0) {\n    return false;\n  }\n  const i = goog.i18n.DateTimeParse.NUMERIC_FORMAT_CHARS_.indexOf(ch);\n  return i > 0 || i == 0 && count < 3;\n};\n\n\n/**\n * Assert this object's pattern supports predictive parsing.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.assertPatternSupportsPredictive_ =\n    function() {\n  'use strict';\n  for (let i = 0; i < this.patternParts_.length; i++) {\n    const part = this.patternParts_[i];\n    if (part.count > 0 &&\n        (goog.i18n.DateTimeParse.PREDICTIVE_FORMAT_CHARS_.indexOf(\n             part.text.charAt(0)) < 0 ||\n         part.count > 2 || part.abutStart)) {\n      throw new Error(\n          `'predictive' parsing is not supported for symbol ` +\n          `'${part.text.charAt(0)}'.`);\n    }\n  }\n};\n\n\n/**\n * Parse the given string and fill parsed values into date object.\n *\n * The existing values of any temporal fields of `date` not parsed from `text`\n * are not directly changed, but may be affected by overflow. E.g. if a minutes\n * value of 70 is parsed, the implementation of `date` may increment the value\n * of its hours field by 1 while setting its minutes value to 10.\n *\n * @param {string} text The string being parsed.\n * @param {?goog.date.DateLike} date The Date object to hold the parsed date.\n * @param {!goog.i18n.DateTimeParse.ParseOptions=} options The options object.\n * @return {number} How many characters parser advanced.\n */\ngoog.i18n.DateTimeParse.prototype.parse = function(text, date, options) {\n  'use strict';\n  let predictive = false;\n  let validate = false;\n  if (options) {\n    predictive = options.predictive || false;\n    validate = options.validate || false;\n  }\n\n  if (predictive) {\n    this.assertPatternSupportsPredictive_();\n  }\n\n  const cal = new goog.i18n.DateTimeParse.MyDate_();\n  const parsePos = [0];\n  cal.dayPeriodIndex = -1;\n\n  for (let i = 0; i < this.patternParts_.length; i++) {\n    if (predictive && parsePos[0] >= text.length) {\n      break;\n    }\n\n    if (this.patternParts_[i].count == 0) {\n      // Handle literal pattern characters.\n      if (this.subParseLiteral_(\n              text, parsePos, this.patternParts_[i], predictive)) {\n        continue;\n      }\n      return 0;\n    }\n\n    if (this.patternParts_[i].abutStart) {\n      // Handle fields within a run of abutting numeric fields.\n      const partsParsed = this.subParseAbut_(text, parsePos, i, cal);\n      if (partsParsed <= 0) {\n        return 0;\n      }\n      i += partsParsed - 1;\n      continue;\n    }\n\n    // Handle non-numeric fields and non-abutting numeric fields.\n    if (!this.subParse_(\n            text, parsePos, this.patternParts_[i], 0, cal, predictive)) {\n      return 0;\n    }\n  }\n\n  // return progress\n  return cal.calcDate_(date, validate) ? parsePos[0] : 0;\n};\n\n/**\n * Parse a run of abutting numeric pattern parts. Take the pattern \"HHmmss\" as\n * an example. We will try to parse 2/2/2 characters of the input text, then if\n * that fails, 1/2/2. We only adjust the width of the leftmost field; the others\n * remain fixed. This allows \"123456\" => 12:34:56, but \"12345\" => 1:23:45.\n * Likewise, for the pattern \"yyyyMMdd\" we try 4/2/2, 3/2/2, 2/2/2, and finally\n * 1/2/2.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {number} abutStart the index of the pattern part starting the run\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object that holds parsed value\n *\n * @return {number} how many pattern parts the parser advanced\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseAbut_ = function(\n    text, pos, abutStart, cal) {\n  'use strict';\n  const start = pos[0];\n  let abutPass = 0;\n\n  let i;\n  for (i = abutStart; i < this.patternParts_.length; i++) {\n    const part = this.patternParts_[i];\n    let count = part.count;\n    if (count === 0) {\n      // Literal pattern parts end abutting runs of numeric fields. Non-numeric\n      // fields do not (possibly a bug or undocumented constraint).\n      break;\n    }\n    // If we are at the start of a run of abutting fields, then\n    // shorten this field in each pass. If we can't shorten\n    // this field any more, then the parse of this set of\n    // abutting numeric fields has failed.\n    if (i == abutStart) {\n      count -= abutPass;\n      abutPass++;\n      if (count == 0) {\n        // tried all possible width, fail now\n        return 0;\n      }\n    }\n\n    // Predictive parsing is not supported for abutting runs of numbers.  We\n    // also enforce that subsequent parts must parse the full number of chars.\n    const requireLength = i > abutStart && part.numeric;\n    const partStart = pos[0];\n    const subParsed = this.subParse_(\n        text, pos, part, count, cal,\n        /* predictive= */ false);\n    if (!subParsed || (requireLength && pos[0] - partStart < count)) {\n      // If the parse fails anywhere in the run, back up to the\n      // start of the run and retry.\n      i = abutStart - 1;\n      pos[0] = start;\n      continue;\n    }\n  }\n\n  return i - abutStart;\n};\n\n\n/**\n * Protected method that converts one field of the input string into a\n * numeric field value.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part for this\n *     field.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object that holds parsed value.\n * @param {boolean} predictive whether to apply predictive parsing rules.\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParse_ = function(\n    text, pos, part, digitCount, cal, predictive) {\n  'use strict';\n  this.skipSpace_(text, pos);\n\n  if (part.numeric && digitCount > 0) {\n    if ((pos[0] + digitCount) > text.length) {\n      return false;\n    }\n  }\n\n  switch (part.text.charAt(0)) {\n    case 'G':  // ERA\n      this.subParseString_(\n          text, pos, [this.dateTimeSymbols_.ERAS], value => cal.era = value);\n      return true;\n    case 'M':  // MONTH\n    case 'L':  // STANDALONEMONTH\n      return this.subParseMonth_(text, pos, digitCount, part, cal);\n    case 'E':  // DAY_OF_WEEK\n      // Handle both short and long forms. Try count == 4 first.\n      const weekdays =\n          [this.dateTimeSymbols_.WEEKDAYS, this.dateTimeSymbols_.SHORTWEEKDAYS];\n      return this.subParseString_(\n          text, pos, weekdays, value => cal.dayOfWeek = value);\n    case 'B':  // Flexible day peridos\n    case 'b':  // Day periods of 'noon', 'midnight', 'am', or 'pm'\n      // TODO b/206042104: update to handle parsing day periods with 'b' and 'B'\n      // Get the strings for the day periods for adjusting the time to AM/PM.\n      // Also includes AM/PM data for fallback.\n      /** {?goog.i18n.DayPeriods} */\n      const localePeriods = DayPeriods.getDayPeriods();\n      // Standard names such as 'noon', 'morning1', 'night2', etc.\n      let periodNames = [];\n      // The localized terms for the period names.\n      let expectedValues = [];\n      if (localePeriods) {\n        // Get the formatNames values to check\n        for (const name of goog.object.getKeys(localePeriods)) {\n          periodNames.push(localePeriods[name].periodName);\n          expectedValues.push(localePeriods[name].formatNames[0]);\n        }\n      }\n      // Add strings for AM & PM, in addition to flexible periods\n      const periodsData = [expectedValues.concat(this.dateTimeSymbols_.AMPMS)];\n      // Include possible outputs of am/pm as day periods.\n      periodNames.push('isAm');\n      periodNames.push('isPm');\n\n      // Record string matching this day period\n      const foundPeriod = this.subParseString_(\n          text, pos, periodsData, value => cal.dayPeriodIndex = value,\n          predictive);\n      cal.dayPeriodName = periodNames[cal.dayPeriodIndex];\n\n      return predictive ? foundPeriod : true;\n    case 'a':  // AM_PM\n      const success = this.subParseString_(\n          text, pos, [this.dateTimeSymbols_.AMPMS], value => cal.ampm = value,\n          predictive);\n      return predictive ? success : true;\n    case 'y':  // YEAR\n      return this.subParseYear_(text, pos, part, digitCount, cal);\n    case 'Q':  // QUARTER\n      // Handle both short and long forms. Try count == 4 first.\n      const quarters =\n          [this.dateTimeSymbols_.QUARTERS, this.dateTimeSymbols_.SHORTQUARTERS];\n      return this.subParseString_(text, pos, quarters, function(value) {\n        cal.month = value * 3;  // First month of quarter.\n        cal.day = 1;\n      });\n    case 'd':  // DATE\n      this.subParseInt_(text, pos, part, digitCount, function(value) {\n        cal.day = value;\n      });\n      return true;\n    case 'S':  // FRACTIONAL_SECOND\n      return this.subParseFractionalSeconds_(text, pos, digitCount, cal);\n    case 'h':  // HOUR (1..12)\n    case 'K':  // HOUR (0..11)\n    case 'H':  // HOUR_OF_DAY (0..23)\n    case 'k':  // HOUR_OF_DAY (1..24)\n    {\n      const success =\n          this.subParseInt_(text, pos, part, digitCount, function(value) {\n            cal.hours =\n                (part.text.charAt(0) === 'h' && value === 12) ? 0 : value;\n          }, predictive);\n      return predictive ? success : true;\n    }\n    case 'm':  // MINUTE\n    {\n      const success =\n          this.subParseInt_(text, pos, part, digitCount, function(value) {\n            cal.minutes = value;\n          }, predictive);\n      return predictive ? success : true;\n    }\n    case 's':  // SECOND\n      this.subParseInt_(text, pos, part, digitCount, function(value) {\n        cal.seconds = value;\n      });\n      return true;\n    case 'z':  // ZONE_OFFSET\n    case 'Z':  // TIMEZONE_RFC\n    case 'v':  // TIMEZONE_GENERIC\n      return this.subParseTimeZoneInGMT_(text, pos, cal);\n    default:\n      return false;\n  }\n};\n\n\n/**\n * Parse year field. Year field is special because\n * 1) two digit year need to be resolved.\n * 2) we allow year to take a sign.\n * 3) year field participate in abut processing.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part for this\n *     field.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseYear_ = function(\n    text, pos, part, digitCount, cal) {\n  'use strict';\n  const start = pos[0];\n  // This awkward implementation preserves an existing behavioral quirk.\n  // digitCount (for abutting patterns) is ignored for signed years.\n  let value = this.parseInt_(text, pos, digitCount);\n  if (value === null) {\n    value = this.parseInt_(text, pos, 0, /* allowSigned= */ true);\n  }\n  if (value === null) {\n    return false;\n  }\n\n  // only if 2 digit was actually parsed, and pattern say it has 2 digit.\n  if (value >= 0 && pos[0] - start == 2 && part.count == 2) {\n    cal.setTwoDigitYear_(value);\n  } else {\n    cal.year = value;\n  }\n  return true;\n};\n\n\n/**\n * Parse Month field.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if parsing successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseMonth_ = function(\n    text, pos, digitCount, part, cal) {\n  'use strict';\n  if (part.numeric &&\n      this.subParseInt_(text, pos, part, digitCount, function(value) {\n        cal.month = value - 1;\n      })) {\n    return true;\n  }\n\n  // month is symbols, i.e., MMM, MMMM, LLL or LLLL\n  // Handle both short and long forms. Try count == 4 first.\n  const months = [\n    this.dateTimeSymbols_.MONTHS, this.dateTimeSymbols_.STANDALONEMONTHS,\n    this.dateTimeSymbols_.SHORTMONTHS,\n    this.dateTimeSymbols_.STANDALONESHORTMONTHS\n  ];\n  return this.subParseString_(text, pos, months, function(value) {\n    cal.month = value;\n  });\n};\n\n\n/**\n * Parse fractional seconds field.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos current parse position.\n * @param {number} digitCount when > 0, numeric parsing must obey the count.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_ = function(\n    text, pos, digitCount, cal) {\n  'use strict';\n  const start = pos[0];\n  const value = this.parseInt_(text, pos, digitCount);\n  if (value === null) {\n    return false;\n  }\n  // Fractional seconds left-justify\n  const len = pos[0] - start;\n  cal.milliseconds = len < 3 ? value * Math.pow(10, 3 - len) :\n                               Math.round(value / Math.pow(10, len - 3));\n  return true;\n};\n\n\n/**\n * Parse GMT type timezone.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos Parse position.\n * @param {!goog.i18n.DateTimeParse.MyDate_} cal object to hold parsed value.\n *\n * @return {boolean} True if successful.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseTimeZoneInGMT_ = function(\n    text, pos, cal) {\n  'use strict';\n  // First try to parse generic forms such as GMT-07:00. Do this first\n  // in case localized DateFormatZoneData contains the string \"GMT\"\n  // for a zone; in that case, we don't want to match the first three\n  // characters of GMT+/-HH:MM etc.\n\n  // For time zones that have no known names, look for strings\n  // of the form:\n  //    GMT[+-]hours:minutes or\n  //    GMT[+-]hhmm or\n  //    GMT.\n  if (text.indexOf('GMT', pos[0]) == pos[0]) {\n    pos[0] += 3;  // 3 is the length of GMT\n  }\n\n  // TODO(user): check for named time zones by looking through the locale\n  // data from the DateFormatZoneData strings. Should parse both short and long\n  // forms.\n  // subParseZoneString(text, start, cal);\n\n  // As a last resort, look for numeric timezones of the form\n  // [+-]hhmm as specified by RFC 822.  This code is actually\n  // a little more permissive than RFC 822.  It will try to do\n  // its best with numbers that aren't strictly 4 digits long.\n\n  if (pos[0] >= text.length) {\n    cal.tzOffset = 0;\n    return true;\n  }\n\n  // Look for hours:minutes or hhmm.\n  const start = pos[0];\n  let value =\n      this.parseInt_(text, pos, /* digitCount= */ 0, /* allowSigned= */ true);\n  if (value === null) {\n    return false;\n  }\n\n  let offset;\n  if (pos[0] < text.length && text.charAt(pos[0]) == ':') {\n    // This is the hours:minutes case\n    offset = value * 60;\n    pos[0]++;\n    value = this.parseInt_(text, pos, /* digitCount= */ 0);\n    if (value === null) {\n      return false;\n    }\n    offset += value;\n  } else {\n    // This is the hhmm case.\n    offset = value;\n    // Assume \"-23\"..\"+23\" refers to hours.\n    if (offset < 24 && (pos[0] - start) <= 3) {\n      offset *= 60;\n    } else {\n      // todo: this looks questionable, should have more error checking\n      offset = offset % 100 + offset / 100 * 60;\n    }\n  }\n\n  cal.tzOffset = -offset;\n  return true;\n};\n\n\n/**\n * Parse unsigned integer pattern characters. These are symbols such as 'd' for\n * date.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part for this\n *     field.\n * @param {number} maxChars when > 0, at most this many characters are parsed.\n * @param {function(number)} callback function to record the parsed value.\n * @param {boolean=} predictive whether to apply predictive parsing rules.\n *     defaults to false\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseInt_ = function(\n    text, pos, part, maxChars, callback, predictive) {\n  'use strict';\n  predictive = predictive || false;\n  const start = pos[0];\n  let value = this.parseInt_(text, pos, maxChars);\n  if (value === null) {\n    return false;\n  } else if (predictive && pos[0] - start < part.count) {\n    if (pos[0] < text.length) {\n      return false;\n    }\n    // Infer trailing 0s to match pattern length.\n    value *= Math.pow(10, part.count - (pos[0] - start));\n  }\n  callback(value);\n  return true;\n};\n\n\n/**\n * Parse string pattern characters. These are symbols matching a set of strings\n * such as 'E' for day of week.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {!Array<!Array<string>>} data Arrays of strings to match against,\n *     sequentially.\n * @param {function(number)} callback function to record the parsed value.\n * @param {boolean=} predictive whether to apply predictive parsing rules.\n *     defaults to false\n *\n * @return {boolean} True iff the input matches any of the strings in the data\n *     arrays.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseString_ = function(\n    text, pos, data, callback, predictive) {\n  'use strict';\n  predictive = predictive || false;\n  let value = null;\n  for (let i = 0; i < data.length; i++) {\n    value = this.matchString_(text, pos, data[i], predictive);\n    if (value !== null) {\n      callback(value);\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * Parse literal pattern characters. These are any quoted characters and non-\n * alphabetic unquoted characters.\n *\n * @param {string} text the text to be parsed.\n * @param {!Array<number>} pos parse position\n * @param {!goog.i18n.DateTimeParse.PatternPart} part the pattern part\n * @param {boolean} predictive whether to apply predictive parsing rules.\n *\n * @return {boolean} True if it parses successfully.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.subParseLiteral_ = function(\n    text, pos, part, predictive) {\n  'use strict';\n  // A run of white space in the pattern matches a run\n  // of white space in the input text.\n  const white_space_match = part.text.match(horizontalWhiteSpacePrefixRegex);\n  if (white_space_match != null) {\n    const start = pos[0];\n    this.skipSpace_(text, pos);\n\n    // Must see at least one white space char in input\n    if (pos[0] > start) {\n      return true;\n    }\n  } else if (text.indexOf(part.text, pos[0]) == pos[0]) {\n    pos[0] += part.text.length;\n    return true;\n  } else if (predictive && part.text.indexOf(text.substring(pos[0])) == 0) {\n    // For predictive matching, if the remaining text is a prefix of the\n    // string literal pattern part, accept it as a match.\n    pos[0] += text.length - pos[0];\n    return true;\n  }\n  // We fall through to this point if the match fails\n  return false;\n};\n\n\n/**\n * Skip space in the string.\n *\n * @param {string} text input string.\n * @param {!Array<number>} pos where skip start, and return back where the skip\n *     stops.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.skipSpace_ = function(text, pos) {\n  'use strict';\n  // Skips Unicode spaces in addition to ASCII space.\n  const m = text.substring(pos[0]).match(skipWhiteSpacePrefixRegex);\n  if (m) {\n    pos[0] += m[0].length;\n  }\n};\n\n\n/**\n * Parse an integer string and return integer value.\n *\n * @param {string} text string being parsed.\n * @param {!Array<number>} pos parse position.\n * @param {number} maxChars when > 0, at most this many characters are parsed.\n * @param {boolean=} allowSigned if true allows a single leading sign character\n *     (+|-) in the input. defaults to false\n *\n * @return {?number} integer value, or null if the integer cannot be parsed\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.parseInt_ = function(\n    text, pos, maxChars, allowSigned) {\n  'use strict';\n  text = maxChars > 0 ? text.substring(0, pos[0] + maxChars) : text;\n  allowSigned = allowSigned || false;\n  // Delocalizes the string containing native digits specified by the locale,\n  // replaces the native digits with ASCII digits. Leaves other characters.\n  // This is the reverse operation of localizeNumbers_ in datetimeformat.js.\n  if (this.dateTimeSymbols_.ZERODIGIT) {\n    const parts = [];\n    for (let i = pos[0]; i < text.length; i++) {\n      const c = text.charCodeAt(i) - this.dateTimeSymbols_.ZERODIGIT;\n      parts.push(\n          (0 <= c && c <= 9) ? String.fromCharCode(c + 0x30) : text.charAt(i));\n    }\n    text = parts.join('');\n  } else {\n    text = text.substring(pos[0]);\n  }\n\n  const signRe = allowSigned ? '[+-]?' : '';\n  const re = new RegExp(`^${signRe}\\\\d+`);\n  const m = text.match(re);\n  if (!m) {\n    return null;\n  }\n  pos[0] += m[0].length;\n  return parseInt(m[0], 10);\n};\n\n\n/**\n * Attempt to match the text at a given position against an array of strings.\n * Since multiple strings in the array may match (for example, if the array\n * contains \"a\", \"ab\", and \"abc\", all will match the input string \"abcd\") the\n * longest match is returned.\n *\n * @param {string} text The string to match to.\n * @param {!Array<number>} pos parsing position.\n * @param {!Array<string>} data The string array of matching patterns.\n * @param {boolean} predictive whether to apply predictive parsing rules.\n *\n * @return {?number} the index of the best match in the array, or null\n *     indicating matching failure.\n * @private\n */\ngoog.i18n.DateTimeParse.prototype.matchString_ = function(\n    text, pos, data, predictive) {\n  'use strict';\n  // There may be multiple strings in the data[] array which begin with\n  // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).\n  // We keep track of the longest match, and return that. Note that this\n  // unfortunately requires us to test all array elements.\n  let bestMatchLength = 0;\n  let bestMatchIndex = null;\n  const lowerText = text.substring(pos[0]).toLowerCase();\n  for (let i = 0; i < data.length; i++) {\n    const lowerData = data[i].toLowerCase();\n    // For predictive parsing the first data string matching the remainder of\n    // the text is considered a match.\n    if (predictive && lowerData.indexOf(lowerText) == 0) {\n      bestMatchLength = lowerText.length;\n      bestMatchIndex = i;\n      break;\n    }\n    // Always compare if we have no match yet; otherwise only compare\n    // against potentially better matches (longer strings).\n    if (data[i].length > bestMatchLength && lowerText.indexOf(lowerData) == 0) {\n      bestMatchLength = data[i].length;\n      bestMatchIndex = i;\n    }\n  }\n  if (bestMatchIndex !== null) {\n    pos[0] += bestMatchLength;\n  }\n  return bestMatchIndex;\n};\n\n\n/**\n * Options object for calls to DateTimeParse.prototype.parse.\n * @record\n */\ngoog.i18n.DateTimeParse.ParseOptions = function() {\n  'use strict';\n  /**\n   * Whether to use predictive parsing. Predictive parsing generates successful\n   * parse results for non-empty partial inputs that have valid completions for\n   * the parse pattern.\n   *\n   * If the end of the input is reached while parsing, numeric patterns parts\n   * such as \"HH\" will infer values by padding with trailing 0s, and string\n   * pattern parts such as \"a\" will attempt to prefix match valid values. E.g.\n   * for the pattern \"HH:mm\" the input \"12:3\" will parse to a value equivalent\n   * to \"12:30\" and for the pattern \"h:mm a\" the input \"12:34 p\" will parse to\n   * a value equivalent to \"12:30 PM\".\n   *\n   * Predictive parsing currently only supports the pattern symbols \"ahHkKm\"\n   * and is not compatible with abutting number patterns. Attempting to parse\n   * using the predictive option with unsupported patterns will result in an\n   * error being thrown.\n   *\n   * Defaults to false.\n   *\n   * @type {boolean|undefined}\n   */\n  this.predictive;\n  /**\n   * Whether the parsed date/time value should be validated.\n   *\n   * When true, parsing will fail if any of the parsed fields overflow, e.g.\n   * minutes > 60.\n   *\n   * Note that setting `validate` to `false` does _not_ mean that parsing will\n   * not fail: if the parser encounters an unknown month or day-of-week name\n   * (for instance) then parsing will still fail. This only checks for overflow.\n   *\n   * Defaults to false.\n   *\n   * @type {boolean|undefined}\n   */\n  this.validate;\n};\n\n\n/**\n * This class hold the intermediate parsing result. After all fields are\n * consumed, final result will be resolved from this class.\n * @constructor\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_ = function() {};\n\n\n/**\n * The date's era.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.era;\n\n\n/**\n * The date's year.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.year;\n\n\n/**\n * The date's month.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.month;\n\n\n/**\n * The date's day of month.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.day;\n\n\n/**\n * The date's hour.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.hours;\n\n\n/**\n * The date's before/afternoon denominator.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.ampm;\n\n/**\n * Index of the time's flexible day period in data object.\n * @type {number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.dayPeriodIndex;\n\n/**\n * The name for flexible time of day.\n * @type {?string}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.dayPeriodName;\n\n/**\n * The date's minutes.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.minutes;\n\n\n/**\n * The date's seconds.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.seconds;\n\n\n/**\n * The date's milliseconds.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.milliseconds;\n\n\n/**\n * The date's timezone offset.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.tzOffset;\n\n\n/**\n * The date's day of week. Sunday is 0, Saturday is 6.\n * @type {?number}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.dayOfWeek;\n\n\n/**\n * Flag indicating if a provided two digit year needs to\n * be disambiguated\n *\n * @type {boolean}\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.ambiguousYear = false;\n\n\n/**\n * 2 digit year special handling. Assuming for example that the\n * defaultCenturyStart is 6/18/1903. This means that two-digit years will be\n * forced into the range 6/18/1903 to 6/17/2003. As a result, years 00, 01, and\n * 02 correspond to 2000, 2001, and 2002. Years 04, 05, etc. correspond\n * to 1904, 1905, etc. If the year is 03, then it is 2003 if the\n * other fields specify a date before 6/18, or 1903 if they specify a\n * date afterwards. As a result, 03 is an ambiguous year. All other\n * two-digit years are unambiguous.\n *\n * @param {number} year 2 digit year value before adjustment.\n * @return {number} disambiguated year.\n * @private\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_ = function(year) {\n  'use strict';\n  const now = new Date();\n  const defaultCenturyStartYear =\n      now.getFullYear() - goog.i18n.DateTimeParse.ambiguousYearCenturyStart;\n  const ambiguousTwoDigitYear = defaultCenturyStartYear % 100;\n  this.ambiguousYear = (year == ambiguousTwoDigitYear);\n  year += Math.floor(defaultCenturyStartYear / 100) * 100 +\n      (year < ambiguousTwoDigitYear ? 100 : 0);\n  return this.year = year;\n};\n\n\n/**\n * Based on the fields set, fill a Date object. For those fields that not\n * set, use the passed in date object's value.\n *\n * @param {?goog.date.DateLike} date Date object to be filled.\n * @param {boolean} validation If true, input date will be checked to make\n *     sure it is valid.\n *\n * @return {boolean} false if fields specify a invalid date.\n * @private\n * @suppress {strictMissingProperties} Added to tighten compiler checks\n */\ngoog.i18n.DateTimeParse.MyDate_.prototype.calcDate_ = function(\n    date, validation) {\n  'use strict';\n  // Throw exception if date is null or undefined.\n  if (date == null) {\n    throw new Error('Parameter \\'date\\' should not be null.');\n  }\n\n  // year 0 is 1 BC, and so on.\n  if (this.era != undefined && this.year != undefined && this.era == 0 &&\n      this.year > 0) {\n    this.year = -(this.year - 1);\n  }\n\n  if (this.year != undefined) {\n    date.setFullYear(this.year);\n  }\n\n  // The setMonth and setDate logic is a little tricky. We need to make sure\n  // day of month is smaller enough so that it won't cause a month switch when\n  // setting month. For example, if data in date is Nov 30, when month is set\n  // to Feb, because there is no Feb 30, JS adjust it to Mar 2. So Feb 12 will\n  // become Mar 12.\n  const orgDate = date.getDate();\n\n  // Every month has a 1st day, this can actually be anything less than 29.\n  date.setDate(1);\n\n  if (this.month != undefined) {\n    date.setMonth(this.month);\n  }\n\n  if (this.day != undefined) {\n    date.setDate(this.day);\n  } else {\n    const maxDate =\n        goog.date.getNumberOfDaysInMonth(date.getFullYear(), date.getMonth());\n    date.setDate(orgDate > maxDate ? maxDate : orgDate);\n  }\n\n  if (typeof date.setHours === 'function') {\n    if (this.hours == undefined) {\n      /**\n       * @suppress {strictMissingProperties} Added to tighten compiler checks\n       */\n      this.hours = date.getHours();\n    }\n    // adjust with am/pm to 24-hour time.\n    if (this.hours < 12) {\n      if (this.ampm != undefined && this.ampm > 0) {\n        // AM or PM explictly set.\n        this.hours += 12;\n      } else {\n        // Handle flexible time of day for PM times from parsed day period.\n        // Noon, afternoons, evenings, are always PM.\n        // Night could be AM or PM, depending on the hour value.\n        //    6 in the evening --\u003e 18:00\n        //   10 at night --\u003e 22:00\n        //    3 at night --\u003e 3:00\n        if (this.dayPeriodName !== undefined) {\n          const pmPeriods = [\n            'isPm', 'noon', 'afternoon1', 'afternoon2', 'evening1', 'evening2'\n          ];\n          if (pmPeriods.includes(this.dayPeriodName) ||\n              (['night1', 'night2'].includes(this.dayPeriodName) &&\n               this.hours >= 6)) {\n            // Adjust to be PM for this day period.\n            this.hours += 12;\n          }\n        }\n      }\n    }\n    date.setHours(this.hours);\n  }\n\n  if (typeof date.setMinutes === 'function' && this.minutes != undefined) {\n    date.setMinutes(this.minutes);\n  }\n\n  if (typeof date.setSeconds === 'function' && this.seconds != undefined) {\n    date.setSeconds(this.seconds);\n  }\n\n  if (typeof date.setMilliseconds === 'function' &&\n      this.milliseconds != undefined) {\n    date.setMilliseconds(this.milliseconds);\n  }\n\n  // If validation is needed, verify that the uncalculated date fields\n  // match the calculated date fields.  We do this before we set the\n  // timezone offset, which will skew all of the dates.\n  //\n  // Don't need to check the day of week as it is guaranteed to be\n  // correct or return false below.\n  if (validation &&\n      (this.year && this.year != date.getFullYear() ||\n       this.month && this.month != date.getMonth() ||\n       this.day && this.day != date.getDate() ||\n       this.hours && this.hours >= 24 || this.minutes && this.minutes >= 60 ||\n       this.seconds && this.seconds >= 60 ||\n       this.milliseconds && this.milliseconds >= 1000)) {\n    return false;\n  }\n\n  // adjust time zone\n  if (this.tzOffset != undefined) {\n    const offset = date.getTimezoneOffset();\n    date.setTime(date.getTime() + (this.tzOffset - offset) * 60 * 1000);\n  }\n\n  // resolve ambiguous year if needed\n  if (this.ambiguousYear) {  // the two-digit year == the default start year\n    const defaultCenturyStart = new Date();\n    defaultCenturyStart.setFullYear(\n        defaultCenturyStart.getFullYear() -\n        goog.i18n.DateTimeParse.ambiguousYearCenturyStart);\n    if (date.getTime() < defaultCenturyStart.getTime()) {\n      date.setFullYear(defaultCenturyStart.getFullYear() + 100);\n    }\n  }\n\n  // dayOfWeek, validation only\n  if (this.dayOfWeek != undefined) {\n    if (this.day == undefined) {\n      // adjust to the nearest day of the week\n      let adjustment = (7 + this.dayOfWeek - date.getDay()) % 7;\n      if (adjustment > 3) {\n        adjustment -= 7;\n      }\n      const orgMonth = date.getMonth();\n      date.setDate(date.getDate() + adjustment);\n\n      // don't let it switch month\n      if (date.getMonth() != orgMonth) {\n        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));\n      }\n    } else if (this.dayOfWeek != date.getDay()) {\n      return false;\n    }\n  }\n  return true;\n};\n});  // End of scope for module data\n"],
"names":["goog","provide","require","requireType","scope","DayPeriods","module","get","i18n","DateTimeParse","PatternPart","horizontalWhiteSpacePrefixRegex","skipWhiteSpacePrefixRegex","goog.i18n.DateTimeParse","pattern","opt_dateTimeSymbols","asserts","assert","undefined","DateTimeSymbols","patternParts_","dateTimeSymbols_","applyStandardPattern_","applyPattern_","ambiguousYearCenturyStart","PATTERN_CHARS_","NUMERIC_FORMAT_CHARS_","PREDICTIVE_FORMAT_CHARS_","prototype","goog.i18n.DateTimeParse.prototype.applyPattern_","inQuote","buf","i","length","ch","charAt","push","text","count","abutStart","numeric","indexOf","getNextCharCount_","isNumericField_","markAbutStart_","goog.i18n.DateTimeParse.prototype.applyStandardPattern_","formatType","DateTimeFormat","Format","SHORT_DATETIME","MEDIUM_DATETIME","DATEFORMATS","TIMEFORMATS","DATETIMEFORMATS","replace","goog.i18n.DateTimeParse.prototype.getNextCharCount_","start","next","goog.i18n.DateTimeParse.prototype.markAbutStart_","abut","goog.i18n.DateTimeParse.prototype.isNumericField_","assertPatternSupportsPredictive_","goog.i18n.DateTimeParse.prototype.assertPatternSupportsPredictive_","part","Error","parse","goog.i18n.DateTimeParse.prototype.parse","date","options","predictive","validate","cal","MyDate_","parsePos","dayPeriodIndex","subParseLiteral_","partsParsed","subParseAbut_","subParse_","calcDate_","goog.i18n.DateTimeParse.prototype.subParseAbut_","pos","abutPass","requireLength","partStart","subParsed","goog.i18n.DateTimeParse.prototype.subParse_","digitCount","skipSpace_","subParseString_","ERAS","value","era","subParseMonth_","weekdays","WEEKDAYS","SHORTWEEKDAYS","dayOfWeek","localePeriods","getDayPeriods","periodNames","expectedValues","name","object","getKeys","periodName","formatNames","periodsData","concat","AMPMS","foundPeriod","dayPeriodName","success","ampm","subParseYear_","quarters","QUARTERS","SHORTQUARTERS","month","day","subParseInt_","subParseFractionalSeconds_","hours","minutes","seconds","subParseTimeZoneInGMT_","goog.i18n.DateTimeParse.prototype.subParseYear_","parseInt_","setTwoDigitYear_","year","goog.i18n.DateTimeParse.prototype.subParseMonth_","months","MONTHS","STANDALONEMONTHS","SHORTMONTHS","STANDALONESHORTMONTHS","goog.i18n.DateTimeParse.prototype.subParseFractionalSeconds_","len","milliseconds","Math","pow","round","goog.i18n.DateTimeParse.prototype.subParseTimeZoneInGMT_","tzOffset","offset","goog.i18n.DateTimeParse.prototype.subParseInt_","maxChars","callback","goog.i18n.DateTimeParse.prototype.subParseString_","data","matchString_","goog.i18n.DateTimeParse.prototype.subParseLiteral_","white_space_match","match","substring","goog.i18n.DateTimeParse.prototype.skipSpace_","m","goog.i18n.DateTimeParse.prototype.parseInt_","allowSigned","ZERODIGIT","parts","c","charCodeAt","String","fromCharCode","join","signRe","re","RegExp","parseInt","goog.i18n.DateTimeParse.prototype.matchString_","bestMatchLength","bestMatchIndex","lowerText","toLowerCase","lowerData","ParseOptions","goog.i18n.DateTimeParse.ParseOptions","goog.i18n.DateTimeParse.MyDate_","ambiguousYear","goog.i18n.DateTimeParse.MyDate_.prototype.setTwoDigitYear_","now","Date","defaultCenturyStartYear","getFullYear","ambiguousTwoDigitYear","floor","goog.i18n.DateTimeParse.MyDate_.prototype.calcDate_","validation","setFullYear","orgDate","getDate","setDate","setMonth","maxDate","getNumberOfDaysInMonth","getMonth","setHours","getHours","pmPeriods","includes","setMinutes","setSeconds","setMilliseconds","getTimezoneOffset","setTime","getTime","defaultCenturyStart","adjustment","getDay","orgMonth"]
}
